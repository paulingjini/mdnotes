<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MDNotes Pro - Professional Markdown Editor</title>

    <!-- External CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/black.css" id="revealTheme">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/material-darker.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/dracula.min.css">

    <style id="appStyles">
        /* CSS Variables for Theming */
:root {
    --bg-primary: #1e1e1e;
    --bg-secondary: #252526;
    --bg-tertiary: #2d2d30;
    --text-primary: #d4d4d4;
    --text-secondary: #808080;
    --border: #3e3e42;
    --accent: #007acc;
    --font-family: 'Consolas', monospace;
    --font-size: 13px;

    /* shadcn compatibility */
    --background: #1e1e1e;
    --foreground: #d4d4d4;
}

/* Theme: Light */
[data-theme="light"] {
    --bg-primary: #fff;
    --bg-secondary: #f0f0f0;
    --bg-tertiary: #e0e0e0;
    --text-primary: #000;
    --text-secondary: #666;
    --border: #ccc;
    --accent: #0066cc;

    --background: #fff;
    --foreground: #000;
}

/* Theme: Dracula */
[data-theme="dracula"] {
    --bg-primary: #282a36;
    --bg-secondary: #1e1f29;
    --bg-tertiary: #44475a;
    --text-primary: #f8f8f2;
    --text-secondary: #6272a4;
    --border: #44475a;
    --accent: #bd93f9;

    --background: #282a36;
    --foreground: #f8f8f2;
}

/* Theme: Nord */
[data-theme="nord"] {
    --bg-primary: #2e3440;
    --bg-secondary: #3b4252;
    --bg-tertiary: #434c5e;
    --text-primary: #eceff4;
    --text-secondary: #d8dee9;
    --border: #4c566a;
    --accent: #88c0d0;

    --background: #2e3440;
    --foreground: #eceff4;
}

/* Theme: Monokai */
[data-theme="monokai"] {
    --bg-primary: #272822;
    --bg-secondary: #1e1f1c;
    --bg-tertiary: #3e3d32;
    --text-primary: #f8f8f2;
    --text-secondary: #75715e;
    --border: #3e3d32;
    --accent: #66d9ef;

    --background: #272822;
    --foreground: #f8f8f2;
}


/* Base Styles and Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: var(--font-family);
    background: var(--bg-primary);
    color: var(--text-primary);
    overflow: hidden;
    height: 100vh;
}

/* Scrollbar Styles */
::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

::-webkit-scrollbar-track {
    background: var(--bg-primary);
}

::-webkit-scrollbar-thumb {
    background: var(--bg-tertiary);
    border-radius: 5px;
}

/* Loading Spinner */
.spinner-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 10000;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
    color: var(--text-primary);
}

.spinner {
    border: 4px solid var(--bg-tertiary);
    border-top: 4px solid var(--accent);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

/* Hidden Utility */
.hidden {
    display: none !important;
}

/* Fullscreen States */
.fullscreen-mode {
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 9999 !important;
    border: none !important;
}

.fullscreen-mode .panel-header {
    display: flex !important;
}


/**
 * shadcn/ui Design System - Pure CSS Implementation
 * Replicates shadcn/ui aesthetics without Tailwind
 */

/* ==================== Color System ==================== */
:root {
    /* Primary Colors */
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;

    /* Secondary Colors */
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;

    /* Muted Colors */
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;

    /* Accent Colors */
    --accent-shadcn: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;

    /* Destructive Colors */
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    /* Border & Input */
    --border-shadcn: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;

    /* Card */
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;

    /* Popover */
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;

    /* Radius */
    --radius: 0.5rem;
}

[data-theme="dark"] {
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;

    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;

    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;

    --accent-shadcn: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border-shadcn: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;

    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;

    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
}

/* ==================== Button Component ==================== */
.btn-shadcn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    white-space: nowrap;
    border-radius: var(--radius);
    font-size: 14px;
    font-weight: 500;
    transition: all 0.15s ease;
    cursor: pointer;
    border: 1px solid transparent;
    outline: none;
    user-select: none;
}

.btn-shadcn:disabled {
    opacity: 0.5;
    pointer-events: none;
}

.btn-shadcn:focus-visible {
    outline: 2px solid hsl(var(--ring));
    outline-offset: 2px;
}

/* Button Variants */
.btn-default {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
}

.btn-default:hover {
    background: hsl(var(--primary) / 0.9);
}

.btn-secondary {
    background: hsl(var(--secondary));
    color: hsl(var(--secondary-foreground));
}

.btn-secondary:hover {
    background: hsl(var(--secondary) / 0.8);
}

.btn-destructive {
    background: hsl(var(--destructive));
    color: hsl(var(--destructive-foreground));
}

.btn-destructive:hover {
    background: hsl(var(--destructive) / 0.9);
}

.btn-outline {
    border: 1px solid hsl(var(--border-shadcn));
    background: transparent;
    color: hsl(var(--primary-foreground));
}

.btn-outline:hover {
    background: hsl(var(--accent-shadcn));
    color: hsl(var(--accent-foreground));
}

.btn-ghost {
    background: transparent;
    color: hsl(var(--primary-foreground));
}

.btn-ghost:hover {
    background: hsl(var(--accent-shadcn));
    color: hsl(var(--accent-foreground));
}

/* Button Sizes */
.btn-sm {
    height: 32px;
    padding: 0 12px;
    font-size: 12px;
}

.btn-md {
    height: 40px;
    padding: 0 16px;
}

.btn-lg {
    height: 48px;
    padding: 0 24px;
    font-size: 16px;
}

.btn-icon {
    width: 40px;
    height: 40px;
    padding: 0;
}

.btn-icon-sm {
    width: 32px;
    height: 32px;
    padding: 0;
}

/* ==================== Card Component ==================== */
.card-shadcn {
    background: hsl(var(--card));
    color: hsl(var(--card-foreground));
    border-radius: var(--radius);
    border: 1px solid hsl(var(--border-shadcn));
    box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
}

.card-header {
    padding: 24px;
    display: flex;
    flex-direction: column;
    gap: 6px;
}

.card-title {
    font-size: 20px;
    font-weight: 600;
    line-height: 1;
    letter-spacing: -0.01em;
}

.card-description {
    font-size: 14px;
    color: hsl(var(--muted-foreground));
}

.card-content {
    padding: 24px;
    padding-top: 0;
}

.card-footer {
    padding: 24px;
    padding-top: 0;
    display: flex;
    align-items: center;
}

/* ==================== Input Component ==================== */
.input-shadcn {
    display: flex;
    height: 40px;
    width: 100%;
    border-radius: var(--radius);
    border: 1px solid hsl(var(--input));
    background: hsl(var(--background));
    padding: 8px 12px;
    font-size: 14px;
    color: hsl(var(--primary-foreground));
    transition: all 0.15s ease;
    outline: none;
}

.input-shadcn:focus {
    outline: 2px solid hsl(var(--ring));
    outline-offset: 2px;
}

.input-shadcn::placeholder {
    color: hsl(var(--muted-foreground));
}

.input-shadcn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* ==================== Label Component ==================== */
.label-shadcn {
    font-size: 14px;
    font-weight: 500;
    line-height: 1;
    color: hsl(var(--primary-foreground));
    display: block;
    margin-bottom: 8px;
}

/* ==================== Select Component ==================== */
.select-shadcn {
    display: flex;
    height: 40px;
    width: 100%;
    border-radius: var(--radius);
    border: 1px solid hsl(var(--input));
    background: hsl(var(--background));
    padding: 8px 12px;
    font-size: 14px;
    color: hsl(var(--primary-foreground));
    transition: all 0.15s ease;
    outline: none;
    cursor: pointer;
}

.select-shadcn:focus {
    outline: 2px solid hsl(var(--ring));
    outline-offset: 2px;
}

/* ==================== Badge Component ==================== */
.badge-shadcn {
    display: inline-flex;
    align-items: center;
    border-radius: 9999px;
    padding: 2px 10px;
    font-size: 12px;
    font-weight: 600;
    transition: all 0.15s ease;
    border: 1px solid transparent;
}

.badge-default {
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
}

.badge-secondary {
    background: hsl(var(--secondary));
    color: hsl(var(--secondary-foreground));
}

.badge-destructive {
    background: hsl(var(--destructive));
    color: hsl(var(--destructive-foreground));
}

.badge-outline {
    color: hsl(var(--primary-foreground));
    border: 1px solid hsl(var(--border-shadcn));
}

/* ==================== Dialog/Modal Component ==================== */
.dialog-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
    background: rgba(0, 0, 0, 0.8);
    animation: fadeIn 0.15s ease;
}

.dialog-content {
    position: fixed;
    left: 50%;
    top: 50%;
    z-index: 50;
    width: 90%;
    max-width: 512px;
    transform: translate(-50%, -50%);
    background: hsl(var(--background));
    border: 1px solid hsl(var(--border-shadcn));
    border-radius: var(--radius);
    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
    animation: scaleIn 0.15s ease;
}

.dialog-header {
    display: flex;
    flex-direction: column;
    gap: 6px;
    padding: 24px;
    padding-bottom: 16px;
}

.dialog-title {
    font-size: 18px;
    font-weight: 600;
    line-height: 1;
    letter-spacing: -0.01em;
}

.dialog-description {
    font-size: 14px;
    color: hsl(var(--muted-foreground));
}

.dialog-footer {
    display: flex;
    flex-direction: column-reverse;
    gap: 8px;
    padding: 24px;
    padding-top: 16px;
}

@media (min-width: 640px) {
    .dialog-footer {
        flex-direction: row;
        justify-content: flex-end;
    }
}

/* ==================== Alert Component ==================== */
.alert-shadcn {
    position: relative;
    width: 100%;
    border-radius: var(--radius);
    border: 1px solid hsl(var(--border-shadcn));
    padding: 16px;
    font-size: 14px;
}

.alert-default {
    background: hsl(var(--background));
    color: hsl(var(--foreground));
}

.alert-destructive {
    border-color: hsl(var(--destructive) / 0.5);
    color: hsl(var(--destructive));
}

.alert-title {
    font-weight: 500;
    line-height: 1;
    margin-bottom: 4px;
}

.alert-description {
    font-size: 14px;
    line-height: 1.5;
    opacity: 0.9;
}

/* ==================== Separator Component ==================== */
.separator-shadcn {
    height: 1px;
    width: 100%;
    background: hsl(var(--border-shadcn));
    margin: 16px 0;
}

.separator-vertical {
    height: auto;
    width: 1px;
    align-self: stretch;
    margin: 0 16px;
}

/* ==================== Tooltip ==================== */
.tooltip-shadcn {
    position: relative;
    display: inline-block;
}

.tooltip-content {
    position: absolute;
    z-index: 50;
    background: hsl(var(--primary));
    color: hsl(var(--primary-foreground));
    padding: 6px 12px;
    border-radius: var(--radius);
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s ease;
}

.tooltip-shadcn:hover .tooltip-content {
    opacity: 1;
}

/* ==================== Animations ==================== */
@keyframes fadeIn {
    from {
        opacity: 0;
    }
    to {
        opacity: 1;
    }
}

@keyframes scaleIn {
    from {
        opacity: 0;
        transform: translate(-50%, -48%) scale(0.95);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* ==================== Notification Toast ==================== */
.toast-container {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 100;
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-width: 400px;
}

.toast {
    background: hsl(var(--card));
    border: 1px solid hsl(var(--border-shadcn));
    border-radius: var(--radius);
    padding: 16px;
    box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1);
    animation: slideDown 0.2s ease;
}

.toast-title {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
}

.toast-description {
    font-size: 13px;
    color: hsl(var(--muted-foreground));
}

.toast-success {
    border-left: 3px solid #22c55e;
}

.toast-error {
    border-left: 3px solid hsl(var(--destructive));
}

.toast-info {
    border-left: 3px solid #3b82f6;
}

.toast-warning {
    border-left: 3px solid #f59e0b;
}

/* ==================== Progress Component ==================== */
.progress-shadcn {
    position: relative;
    height: 16px;
    width: 100%;
    overflow: hidden;
    border-radius: 9999px;
    background: hsl(var(--secondary));
}

.progress-indicator {
    height: 100%;
    background: hsl(var(--primary));
    transition: all 0.2s ease;
    border-radius: 9999px;
}

/* ==================== Switch Component ==================== */
.switch-shadcn {
    position: relative;
    display: inline-flex;
    width: 44px;
    height: 24px;
    border-radius: 9999px;
    background: hsl(var(--input));
    cursor: pointer;
    transition: background 0.15s ease;
}

.switch-shadcn.checked {
    background: hsl(var(--primary));
}

.switch-thumb {
    position: absolute;
    width: 20px;
    height: 20px;
    background: white;
    border-radius: 9999px;
    top: 2px;
    left: 2px;
    transition: transform 0.15s ease;
    box-shadow: 0 2px 4px rgb(0 0 0 / 0.2);
}

.switch-shadcn.checked .switch-thumb {
    transform: translateX(20px);
}

/* ==================== Scrollbar Styling ==================== */
.scrollbar-shadcn {
    overflow-y: auto;
}

.scrollbar-shadcn::-webkit-scrollbar {
    width: 10px;
}

.scrollbar-shadcn::-webkit-scrollbar-track {
    background: hsl(var(--muted));
    border-radius: 5px;
}

.scrollbar-shadcn::-webkit-scrollbar-thumb {
    background: hsl(var(--muted-foreground) / 0.3);
    border-radius: 5px;
}

.scrollbar-shadcn::-webkit-scrollbar-thumb:hover {
    background: hsl(var(--muted-foreground) / 0.5);
}


/* Component Styles */

/* Header */
.header {
    background: var(--bg-secondary);
    padding: 10px 15px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.header h1 {
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 8px;
}

.header .btn-group {
    display: flex;
    gap: 5px;
}

/* Toolbar */
.toolbar {
    background: var(--bg-tertiary);
    padding: 8px 15px;
    border-bottom: 1px solid var(--border);
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
    align-items: center;
}

.separator {
    width: 1px;
    height: 20px;
    background: var(--border);
    margin: 0 5px;
}

/* Buttons */
.btn, .toolbar-btn, .icon-btn {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 6px 12px;
    font-size: 12px;
    cursor: pointer;
    font-family: inherit;
    border-radius: 4px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    transition: all 0.2s;
}

.btn:hover, .toolbar-btn:hover, .icon-btn:hover {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}

.btn.active, .toolbar-btn.active {
    background: var(--accent);
    color: white;
}

.icon-btn {
    padding: 6px;
    min-width: 30px;
}

.toolbar-btn {
    padding: 5px 8px;
}

/* Icons */
.icon {
    width: 16px;
    height: 16px;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
    fill: none;
}

/* Toolbar Style Variants */
body[data-toolbar-style="icon-only"] .toolbar-btn span {
    display: none;
}

body[data-toolbar-style="text-only"] .toolbar-btn .icon {
    display: none;
}

body[data-toolbar-style="icon-text"] .toolbar-btn {
    padding: 5px 10px;
}

/* Dropdown Menu */
.export-btn-group {
    position: relative;
}

.dropdown-menu {
    display: none;
    position: absolute;
    top: 100%;
    right: 0;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 4px;
    min-width: 180px;
    z-index: 100;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    margin-top: 5px;
}

.dropdown-menu.show {
    display: block;
}

.dropdown-item {
    padding: 8px 15px;
    font-size: 12px;
    color: var(--text-primary);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
}

.dropdown-item:hover {
    background-color: var(--accent);
}

/* Main Container */
.main-container {
    display: flex;
    height: calc(100vh - 90px);
}

/* File Manager */
.file-manager {
    width: 250px;
    background: var(--bg-secondary);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
}

.file-manager.hidden {
    display: none;
}

.file-manager-header {
    padding: 8px 10px;
    background: var(--bg-tertiary);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    font-weight: bold;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.file-list {
    flex: 1;
    overflow-y: auto;
}

/* Folder Items */
.folder-item {
    padding: 6px 10px;
    cursor: pointer;
    font-size: 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
    transition: background 0.2s;
}

.folder-item:hover {
    background: var(--bg-tertiary);
}

.folder-toggle {
    cursor: pointer;
    width: 14px;
    text-align: center;
    font-size: 10px;
    color: var(--text-secondary);
}

.folder-icon {
    font-size: 14px;
}

.folder-name {
    flex: 1;
    font-weight: 500;
}

.folder-actions {
    display: none;
    gap: 4px;
}

.folder-item:hover .folder-actions {
    display: flex;
}

.action-btn {
    background: none;
    border: none;
    cursor: pointer;
    padding: 2px;
    font-size: 12px;
    opacity: 0.7;
    transition: opacity 0.2s;
}

.action-btn:hover {
    opacity: 1;
}

/* File Items */
.file-item {
    padding: 6px 10px;
    cursor: pointer;
    font-size: 12px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
    transition: background 0.2s;
}

.file-item:hover {
    background: var(--bg-tertiary);
}

.file-item.active {
    background: var(--accent);
    color: white;
}

.file-icon {
    font-size: 14px;
}

.file-name {
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.file-actions {
    display: none;
    gap: 4px;
}

.file-item:hover .file-actions {
    display: flex;
}

.file-item .delete-btn {
    opacity: 0;
    background: none;
    border: none;
    cursor: pointer;
}

.file-item:hover .delete-btn {
    opacity: 1;
}

.file-item .delete-btn .icon:hover {
    color: #f44336;
}

/* Drag & Drop Styles */
.folder-item.dragging,
.file-item.dragging {
    opacity: 0.5;
    background: var(--bg-tertiary);
    cursor: move;
}

.folder-item.drag-over {
    background: var(--accent);
    border-color: var(--accent);
    color: white !important;
    box-shadow: 0 0 0 2px var(--accent);
    transition: all 0.2s ease;
    cursor: copy;
}

.folder-item.drag-over * {
    color: white !important;
}

/* Cursor styles for dragging */
.folder-item[draggable="true"]:hover {
    cursor: grab;
}

.file-item[draggable="true"]:hover {
    cursor: grab;
}

.folder-item[draggable="true"]:active,
.file-item[draggable="true"]:active {
    cursor: grabbing;
}

.folder-count {
    font-size: 10px;
    color: var(--text-secondary);
    margin-left: auto;
}

.folder-select-item {
    padding: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.2s;
    display: flex;
    align-items: center;
    gap: 8px;
}

.folder-select-item:hover {
    background: var(--bg-tertiary);
}

/* File Tags */
.file-tag {
    display: inline-block;
    padding: 2px 6px;
    font-size: 10px;
    border-radius: 10px;
    color: white;
    white-space: nowrap;
    cursor: pointer;
}

.file-tag:hover {
    opacity: 0.8;
}

/* Panels */
.editor-panel, .preview-panel, .mindmap-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    border-right: 1px solid var(--border);
    min-width: 0;
}

.editor-panel.hidden, .preview-panel.hidden, .mindmap-panel.hidden {
    display: none;
}

.panel-header {
    background: var(--bg-tertiary);
    padding: 5px 10px;
    font-size: 11px;
    border-bottom: 1px solid var(--border);
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.panel-header .icon-btn {
    padding: 2px;
}

/* Editor */
#mdToolbar {
    background: var(--bg-secondary);
    padding: 5px 10px;
    border-bottom: 1px solid var(--border);
    display: flex;
    gap: 5px;
    flex-wrap: wrap;
}

#mdToolbar .btn {
    font-size: 14px;
    font-weight: bold;
    padding: 4px 8px;
    min-width: 28px;
    text-align: center;
}

/* CodeMirror Override Styles */
.CodeMirror {
    height: 100% !important;
    font-family: var(--font-family) !important;
    font-size: var(--font-size) !important;
    background: var(--bg-primary) !important;
    color: var(--text-primary) !important;
}

.CodeMirror-gutters {
    background: var(--bg-secondary) !important;
    border-right: 1px solid var(--border) !important;
}

.CodeMirror-linenumber {
    color: var(--text-secondary) !important;
}

.CodeMirror-cursor {
    border-left: 2px solid var(--accent) !important;
}

.CodeMirror-selected {
    background: rgba(0, 122, 204, 0.2) !important;
}

/* Fallback Editor (Textarea) */
#editor {
    flex: 1;
    background: var(--bg-primary);
    color: var(--text-primary);
    border: none;
    padding: 15px;
    font-family: inherit;
    font-size: var(--font-size);
    line-height: 1.6;
    resize: none;
    outline: none;
}

/* Preview */
#preview {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    background: var(--bg-primary);
    font-size: var(--font-size);
}

/* Preview Markdown Styles */
#preview h1 {
    font-size: 2em;
    margin: 0.67em 0;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    padding-bottom: .3em;
}

#preview h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
    color: var(--accent);
    border-bottom: 1px solid var(--border);
    padding-bottom: .3em;
}

#preview h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

#preview p {
    margin: 1em 0;
    line-height: 1.7;
}

#preview code:not(pre code) {
    background: var(--bg-tertiary);
    padding: .2em .4em;
    font-size: 85%;
    border-radius: 6px;
}

#preview pre {
    background: var(--bg-tertiary);
    padding: 16px;
    overflow-x: auto;
    border-radius: 6px;
}

#preview pre code {
    padding: 0;
    background: none;
}

#preview blockquote {
    border-left: .25em solid var(--border);
    padding: 0 1em;
    color: var(--text-secondary);
    margin: 0;
}

#preview ul, #preview ol {
    padding-left: 2em;
    margin: 1em 0;
}

#preview table {
    border-collapse: collapse;
    margin: 1em 0;
}

#preview th, #preview td {
    border: 1px solid var(--border);
    padding: 6px 13px;
}

#preview th {
    font-weight: bold;
    background-color: var(--bg-tertiary);
}

#preview tr:nth-child(2n) {
    background-color: var(--bg-secondary);
}

/* Mindmap */
#mindmap {
    flex: 1;
    background: var(--bg-primary);
}

#mindmap svg {
    width: 100%;
    height: 100%;
}

/* Mindmap active node highlighting */
.mindmap-active-node {
    stroke: var(--accent) !important;
    stroke-width: 4px !important;
    filter: drop-shadow(0 0 8px var(--accent));
    animation: mindmapPulse 1.5s ease-in-out infinite;
}

@keyframes mindmapPulse {
    0%, 100% {
        stroke-width: 4px;
        opacity: 1;
    }
    50% {
        stroke-width: 6px;
        opacity: 0.8;
    }
}

/* Status Bar */
.status-bar {
    background: var(--bg-secondary);
    border-top: 1px solid var(--border);
    padding: 4px 20px;
    font-size: 11px;
    color: var(--text-secondary);
    display: flex;
    justify-content: space-between;
}

/* Form Elements */
select, .btn-group {
    display: flex;
    gap: 5px;
    align-items: center;
}

select {
    background: var(--bg-secondary);
    color: var(--text-primary);
    border: 1px solid var(--border);
    padding: 6px;
    font-size: 12px;
    font-family: inherit;
    border-radius: 4px;
}

#fileInput {
    display: none;
}

/* Sync Highlighting */
.sync-highlight {
    background: rgba(0, 122, 204, 0.1);
    border-left: 3px solid var(--accent);
    padding-left: 12px;
    margin-left: -15px;
    transition: all 0.3s ease;
}

.sync-highlight:hover {
    background: rgba(0, 122, 204, 0.15);
}

/* Bidirectional Editing */
.editable-element {
    cursor: pointer;
    transition: background-color 0.2s, padding-left 0.2s;
    border-radius: 4px;
}

.editable-element:hover {
    background-color: rgba(0, 122, 204, 0.08);
    padding-left: 8px;
}

.editable-element:active {
    background-color: rgba(0, 122, 204, 0.15);
}

/* Editor line highlight (for CodeMirror) */
.editor-highlight-line {
    background-color: rgba(0, 122, 204, 0.2) !important;
    animation: fadeHighlight 2s ease-out;
}

@keyframes fadeHighlight {
    0% { background-color: rgba(0, 122, 204, 0.3); }
    100% { background-color: rgba(0, 122, 204, 0.1); }
}

/* Interactive Tables */
.interactive-table-wrapper {
    margin: 20px 0;
    border: 1px solid var(--border);
    border-radius: 6px;
    overflow: hidden;
}

.table-toolbar {
    background: var(--bg-secondary);
    padding: 10px;
    display: flex;
    gap: 10px;
    align-items: center;
    border-bottom: 1px solid var(--border);
}

.table-filter {
    flex: 1;
}

.table-filter-input {
    width: 100%;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 12px;
}

.table-export-btn {
    padding: 6px 12px;
    font-size: 12px;
    white-space: nowrap;
}

.table-row-count {
    font-size: 11px;
    color: var(--text-secondary);
    white-space: nowrap;
}

.interactive-table {
    width: 100%;
}

.interactive-table thead th {
    user-select: none;
    position: relative;
    transition: background 0.2s;
}

.interactive-table thead th:hover {
    background: var(--bg-tertiary) !important;
}

.sort-icon {
    color: var(--text-secondary);
    font-size: 10px;
    opacity: 0.6;
}

.interactive-table thead th:hover .sort-icon {
    opacity: 1;
}

/* Task Lists */
.task-list-item {
    list-style: none;
    display: flex;
    align-items: flex-start;
    gap: 8px;
    margin: 8px 0;
    padding: 8px;
    border-radius: 4px;
    transition: background 0.2s, transform 0.2s;
}

.task-list-item:hover {
    background: var(--bg-secondary);
}

.task-updating {
    transform: scale(0.98);
    opacity: 0.7;
}

.task-checkbox {
    margin-top: 3px;
    cursor: pointer;
    width: 16px;
    height: 16px;
    accent-color: var(--accent);
}

.task-label {
    flex: 1;
    cursor: pointer;
    transition: all 0.3s;
}

.task-label.completed {
    text-decoration: line-through;
    opacity: 0.6;
    color: var(--text-secondary);
}

.task-progress {
    margin: 10px 0;
    padding: 10px;
    background: var(--bg-secondary);
    border-radius: 6px;
}

.task-progress-bar {
    height: 8px;
    background: var(--bg-tertiary);
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 6px;
}

.task-progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #00cc88);
    transition: width 0.3s ease;
    border-radius: 4px;
}

.task-progress-text {
    font-size: 11px;
    color: var(--text-secondary);
    text-align: center;
}


/* Modal Dialogs */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

.modal-content {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    padding: 20px;
    min-width: 400px;
    max-width: 90%;
    max-height: 80vh;
    overflow-y: auto;
    border-radius: 8px;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}

.modal-title {
    font-size: 16px;
    color: var(--accent);
}

.modal-header .icon-btn {
    background: none;
    border: none;
}

/* Form Groups */
.form-group {
    margin-bottom: 15px;
}

.form-group label {
    display: block;
    margin-bottom: 5px;
    font-size: 12px;
    color: var(--text-secondary);
}

.form-group input,
.form-group textarea,
.form-group select {
    width: 100%;
    padding: 8px;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    color: var(--text-primary);
    font-family: inherit;
    font-size: 13px;
    border-radius: 4px;
}

.form-group textarea {
    min-height: 200px;
    resize: vertical;
}

.modal-actions {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
    margin-top: 20px;
}

/* Theme Presets */
.theme-preset {
    display: inline-block;
    width: 60px;
    height: 40px;
    border: 2px solid var(--border);
    cursor: pointer;
    margin-right: 10px;
    border-radius: 4px;
}

.theme-preset:hover {
    border-color: var(--accent);
}

.theme-preset.active {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px var(--accent);
}

/* Help Modal */
#helpModal .modal-content {
    min-width: 60vw;
}

#helpModal h2 {
    font-size: 1.2em;
    color: var(--accent);
    margin-top: 15px;
    margin-bottom: 10px;
}

#helpModal p {
    font-size: 13px;
    line-height: 1.6;
    margin-bottom: 10px;
}

#helpModal code {
    background: var(--bg-tertiary);
    padding: 2px 5px;
    border-radius: 4px;
    font-family: inherit;
}

#helpModal kbd {
    background: var(--bg-tertiary);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 3px 6px;
    font-size: 0.9em;
}


/**
 * Block-Based Editor Styles
 * Notion-style blocks with contentEditable
 */

/* Block Editor Container */
.block-editor-container {
    flex: 1;
    overflow-y: auto;
    height: 100%;
    display: flex;
    flex-direction: column;
}

.block-editor-container.hidden {
    display: none !important;
}

/* Block Container */
.block-container {
    display: flex;
    align-items: flex-start;
    padding: 3px 0;
    position: relative;
    transition: background 0.1s ease;
}

.block-container:hover {
    background: var(--bg-tertiary);
}

.block-container.block-focused {
    background: var(--bg-tertiary);
}

/* Block Handle (Drag Icon) */
.block-handle {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    cursor: grab;
    color: var(--text-secondary);
    font-size: 14px;
    margin-right: 4px;
    transition: opacity 0.2s ease;
    user-select: none;
}

.block-container:hover .block-handle {
    opacity: 1;
}

.block-handle:active {
    cursor: grabbing;
}

/* Block Content Area */
.block-content-area {
    flex: 1;
    min-width: 0;
}

/* Block Content (contentEditable) */
.block-content {
    outline: none;
    padding: 3px 2px;
    min-height: 1.5em;
    line-height: 1.6;
    color: var(--text-primary);
    position: relative;
}

.block-content:empty:before {
    content: attr(data-placeholder);
    color: var(--text-secondary);
    opacity: 0.5;
    pointer-events: none;
}

/* Block Prefix (non-editable) */
.block-prefix {
    user-select: none;
    color: var(--text-secondary);
    margin-right: 4px;
    font-weight: 600;
}

/* Block Types */
.block-type-h1 {
    font-size: 32px;
    font-weight: 700;
    margin: 12px 0 8px 0;
    line-height: 1.3;
}

.block-type-h2 {
    font-size: 24px;
    font-weight: 600;
    margin: 10px 0 6px 0;
    line-height: 1.4;
}

.block-type-h3 {
    font-size: 18px;
    font-weight: 600;
    margin: 8px 0 4px 0;
    line-height: 1.4;
}

.block-type-text {
    font-size: 14px;
}

.block-type-todo {
    font-size: 14px;
}

.block-type-todo .block-prefix {
    cursor: pointer;
    user-select: none;
}

.block-type-todo .block-prefix:hover {
    color: var(--accent);
}

.block-type-bullet {
    font-size: 14px;
}

.block-type-numbered {
    font-size: 14px;
}

.block-type-quote {
    font-size: 14px;
    font-style: italic;
    border-left: 3px solid var(--border);
    padding-left: 12px;
    color: var(--text-secondary);
}

.block-type-code {
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    background: var(--bg-tertiary);
    padding: 8px 12px;
    border-radius: 4px;
    border: 1px solid var(--border);
}

.block-type-toggle {
    font-size: 14px;
}

.block-type-toggle .block-prefix {
    cursor: pointer;
    transition: transform 0.2s ease;
}

.block-type-toggle.expanded .block-prefix {
    transform: rotate(90deg);
}

/* Slash Command Menu */
.slash-menu {
    position: fixed;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    padding: 6px;
    min-width: 280px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 1000;
    animation: slideDown 0.15s ease;
}

@keyframes slideDown {
    from {
        opacity: 0;
        transform: translateY(-5px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.slash-menu-item {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.1s ease;
    gap: 12px;
}

.slash-menu-item:hover {
    background: var(--bg-tertiary);
}

.slash-menu-icon {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-tertiary);
    border-radius: 4px;
    font-size: 16px;
    flex-shrink: 0;
}

.slash-menu-title {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-primary);
    margin-bottom: 2px;
}

.slash-menu-desc {
    font-size: 12px;
    color: var(--text-secondary);
}

/* Block Editor Container */
.block-editor {
    padding: 40px 96px;
    max-width: 900px;
    margin: 0 auto;
}

.block-editor-title {
    font-size: 40px;
    font-weight: 700;
    margin-bottom: 24px;
    padding: 8px 0;
    outline: none;
    border: none;
    background: transparent;
    width: 100%;
    color: var(--text-primary);
}

.block-editor-title:empty:before {
    content: 'Untitled';
    color: var(--text-secondary);
    opacity: 0.5;
}

.block-editor-blocks {
    margin-top: 16px;
}

/* Nested Blocks (Indented) */
.block-nested {
    margin-left: 24px;
    border-left: 1px solid var(--border);
    padding-left: 12px;
}

/* Block Selection */
.block-container.selected {
    background: rgba(var(--accent), 0.1);
}

/* Block Hover Actions */
.block-actions {
    position: absolute;
    left: -40px;
    top: 3px;
    display: none;
    align-items: center;
    gap: 4px;
}

.block-container:hover .block-actions {
    display: flex;
}

.block-action-btn {
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 4px;
    cursor: pointer;
    opacity: 0.7;
    transition: all 0.2s ease;
    font-size: 14px;
}

.block-action-btn:hover {
    opacity: 1;
    background: var(--bg-tertiary);
}

/* Drag and Drop States */
.block-container.dragging {
    opacity: 0.5;
}

.block-container.drag-over {
    border-top: 2px solid var(--accent);
}

/* Block Placeholder (when empty page) */
.block-editor-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    color: var(--text-secondary);
    text-align: center;
}

.block-editor-empty-icon {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
}

.block-editor-empty-text {
    font-size: 16px;
    margin-bottom: 8px;
}

.block-editor-empty-hint {
    font-size: 14px;
    opacity: 0.7;
}

/* Responsive */
@media (max-width: 768px) {
    .block-editor {
        padding: 24px 20px;
    }

    .block-editor-title {
        font-size: 32px;
    }

    .block-type-h1 {
        font-size: 28px;
    }

    .block-type-h2 {
        font-size: 22px;
    }

    .block-type-h3 {
        font-size: 16px;
    }
}

/* Loading State */
.block-editor-loading {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 40px;
    color: var(--text-secondary);
}

.block-editor-loading::after {
    content: '...';
    animation: loading 1.5s infinite;
}

@keyframes loading {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
}

/* Scrollbar for Slash Menu */
.slash-menu::-webkit-scrollbar {
    width: 8px;
}

.slash-menu::-webkit-scrollbar-track {
    background: var(--bg-secondary);
}

.slash-menu::-webkit-scrollbar-thumb {
    background: var(--text-secondary);
    border-radius: 4px;
}

.slash-menu::-webkit-scrollbar-thumb:hover {
    background: var(--accent);
}



    </style>
</head>
<body data-toolbar-style="icon-only">

    <!-- Header -->
    <div class="header">
        <h1 id="appTitle">
            <svg class="icon" style="width:20px; height:20px" viewBox="0 0 24 24"><use href="#icon-edit"></use></svg>
            <span>MDNotes Pro</span>
        </h1>
        <div class="btn-group">
            <button class="btn" onclick="app.showNewFileModal()">+ New</button>
            <button class="btn" onclick="document.getElementById('fileInput').click()">üìÅ Open</button>
            <button class="icon-btn" onclick="app.showSettings()" title="Settings">
                <svg class="icon"><use href="#icon-settings"></use></svg>
            </button>
            <button class="icon-btn" onclick="app.showHelp()" title="Help">
                <svg class="icon"><use href="#icon-help"></use></svg>
            </button>
        </div>
    </div>

    <!-- Toolbar -->
    <div class="toolbar">
        <button class="toolbar-btn" onclick="app.toggleFileManager()" title="Toggle File Manager">
            <svg class="icon"><use href="#icon-folder"></use></svg>
            <span>Files</span>
        </button>
        <div class="separator"></div>
        <div class="btn-group">
            <button class="toolbar-btn active" id="btnEditor" onclick="app.toggleView('editor')" title="Editor">
                <svg class="icon"><use href="#icon-edit"></use></svg>
                <span>Editor</span>
            </button>
            <button class="toolbar-btn" id="btnPreview" onclick="app.toggleView('preview')" title="Preview">
                <svg class="icon"><use href="#icon-eye"></use></svg>
                <span>Preview</span>
            </button>
            <button class="toolbar-btn" id="btnMindmap" onclick="app.toggleView('mindmap')" title="Mindmap">
                <svg class="icon"><use href="#icon-git-branch"></use></svg>
                <span>Mindmap</span>
            </button>
        </div>
        <div class="separator"></div>
        <button class="toolbar-btn" id="btnEditorMode" onclick="app.toggleEditorMode()" title="Toggle Editor Mode (Markdown ‚Üî Blocks)">
            <svg class="icon"><use href="#icon-layers"></use></svg>
            <span id="editorModeLabel">Markdown</span>
        </button>
        <div class="separator"></div>
        <button class="toolbar-btn" onclick="app.save()" title="Save (Ctrl+S)">
            <svg class="icon"><use href="#icon-save"></use></svg>
            <span>Save</span>
        </button>
        <div class="export-btn-group">
            <button class="toolbar-btn" onclick="app.toggleExportMenu()" title="Export">
                <svg class="icon"><use href="#icon-download"></use></svg>
                <span>Export</span>
            </button>
            <div class="dropdown-menu" id="exportMenu">
                <div class="dropdown-item" onclick="app.exportAs('md')">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-file-text"></use></svg>
                    <span>as Markdown (.md)</span>
                </div>
                <div class="dropdown-item" onclick="app.exportAs('html')">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-code"></use></svg>
                    <span>as HTML (.html)</span>
                </div>
                <div class="dropdown-item" onclick="app.exportAs('pdf-preview')">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-file"></use></svg>
                    <span>as PDF (Preview)</span>
                </div>
                <div class="dropdown-item" onclick="app.exportAs('pdf-slides')">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-image"></use></svg>
                    <span>as PDF (Slides)</span>
                </div>
                <div class="dropdown-item" onclick="app.exportAs('pptx')">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-presentation"></use></svg>
                    <span>as PowerPoint (.pptx)</span>
                </div>
            </div>
        </div>
        <div class="separator"></div>
        <button class="toolbar-btn" id="btnPresentation" onclick="app.togglePresentation()" title="Present">
            <svg class="icon"><use href="#icon-play"></use></svg>
            <span>Present</span>
        </button>
        <button class="toolbar-btn" onclick="app.showPresentationSettings()" title="Presentation Settings">
            <svg class="icon"><use href="#icon-sliders"></use></svg>
            <span>Templates</span>
        </button>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- File Manager -->
        <div class="file-manager" id="fileManager">
            <div class="file-manager-header">FILES</div>
            <div class="file-list" id="fileList"></div>
        </div>

        <!-- Editor Panel -->
        <div class="editor-panel" id="editorPanel">
            <div class="panel-header">
                <span>EDITOR</span>
                <button class="icon-btn" onclick="app.toggleEditorFullscreen()" title="Fullscreen">
                    <svg class="icon"><use href="#icon-maximize"></use></svg>
                </button>
            </div>
            <div id="mdToolbar">
                <button class="btn" onclick="app.insertMarkdown('**', '**', 'bold')" title="Bold (Ctrl+B)">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-bold"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('*', '*', 'italic')" title="Italic (Ctrl+I)">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-italic"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('`', '`', 'code')" title="Inline Code">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-code"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('\n> ', '', 'Quote')" title="Blockquote">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-quote"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('\n- ', '', 'List item')" title="Unordered List">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-list"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('\n1. ', '', 'List item')" title="Ordered List">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-ol"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('\n- [ ] ', '', 'Task')" title="Task List">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-check-square"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('[', '](url)', 'link text')" title="Link (Ctrl+K)">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-link"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('![', '](url)', 'alt text')" title="Image">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-image"></use></svg>
                </button>
                <button class="btn" onclick="app.insertMarkdown('\n```\n', '\n```\n', 'code')" title="Code Block">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-code-block"></use></svg>
                </button>
            </div>
            <textarea id="editor" spellcheck="false"></textarea>
            <div id="blockEditorContainer" class="block-editor-container hidden"></div>
        </div>

        <!-- Preview Panel -->
        <div class="preview-panel hidden" id="previewPanel">
            <div class="panel-header">
                <span id="previewTitle">PREVIEW</span>
                <button class="icon-btn" onclick="app.togglePreviewFullscreen()" title="Fullscreen">
                    <svg class="icon"><use href="#icon-maximize"></use></svg>
                </button>
            </div>
            <div id="preview"></div>
        </div>

        <!-- Mindmap Panel -->
        <div class="mindmap-panel hidden" id="mindmapPanel">
            <div class="panel-header">
                <span>MINDMAP</span>
                <button class="icon-btn" onclick="app.toggleMindmapFullscreen()" title="Fullscreen">
                    <svg class="icon"><use href="#icon-maximize"></use></svg>
                </button>
            </div>
            <div id="mindmap">
                <div style="text-align:center;padding:50px;color:var(--text-secondary)">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="status-bar">
        <span id="statusLeft">Ready</span>
        <span id="statusRight">Lines: 0 | Words: 0 | Chars: 0</span>
    </div>

    <!-- File Input -->
    <input type="file" id="fileInput" accept=".md,.txt" multiple onchange="app.loadExternalFiles(event)">

    <!-- Settings Modal -->
<div class="modal" id="settingsModal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">‚öôÔ∏è Settings</div>
            <button class="icon-btn" onclick="app.closeModal()">
                <svg class="icon"><use href="#icon-close"></use></svg>
            </button>
        </div>

        <div class="form-group">
            <label>App Name</label>
            <input type="text" id="appNameInput" onchange="app.setAppName(this.value)">
        </div>

        <div class="form-group">
            <label>Toolbar Style</label>
            <select id="toolbarStyleSelect" onchange="app.setToolbarStyle(this.value)">
                <option value="icon-only">Icon Only</option>
                <option value="icon-text">Icon & Text</option>
                <option value="text-only">Text Only</option>
            </select>
        </div>

        <div class="form-group">
            <label>Theme</label>
            <div style="margin:10px 0">
                <div class="theme-preset active" data-theme="dark" style="background:linear-gradient(to right,#1e1e1e,#2d2d30)" onclick="app.setTheme('dark')"></div>
                <div class="theme-preset" data-theme="light" style="background:linear-gradient(to right,#fff,#f0f0f0)" onclick="app.setTheme('light')"></div>
                <div class="theme-preset" data-theme="dracula" style="background:linear-gradient(to right,#282a36,#44475a)" onclick="app.setTheme('dracula')"></div>
                <div class="theme-preset" data-theme="nord" style="background:linear-gradient(to right,#2e3440,#3b4252)" onclick="app.setTheme('nord')"></div>
                <div class="theme-preset" data-theme="monokai" style="background:linear-gradient(to right,#272822,#3e3d32)" onclick="app.setTheme('monokai')"></div>
            </div>
        </div>

        <div class="form-group">
            <label>Font</label>
            <select id="fontSelect" onchange="app.setFont(this.value)">
                <option value="'Consolas',monospace">Consolas</option>
                <option value="'Fira Code',monospace">Fira Code</option>
                <option value="'Source Code Pro',monospace">Source Code Pro</option>
                <option value="'JetBrains Mono',monospace">JetBrains Mono</option>
                <option value="'Roboto Mono',monospace">Roboto Mono</option>
            </select>
        </div>

        <div class="form-group">
            <label>Font Size</label>
            <select id="sizeSelect" onchange="app.setFontSize(this.value)">
                <option>11px</option>
                <option>12px</option>
                <option selected>13px</option>
                <option>14px</option>
                <option>15px</option>
                <option>16px</option>
                <option>18px</option>
            </select>
        </div>

        <div class="modal-actions">
            <button class="btn" onclick="app.closeModal()">Close</button>
        </div>
    </div>
</div>

<!-- New File Modal -->
<div class="modal" id="newFileModal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">New File</div>
            <button class="icon-btn" onclick="app.closeModal()">
                <svg class="icon"><use href="#icon-close"></use></svg>
            </button>
        </div>
        <div class="form-group">
            <label>Filename:</label>
            <input type="text" id="newFileName" placeholder="filename.md" onkeypress="if(event.key==='Enter') app.createFile()">
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="app.closeModal()">Cancel</button>
            <button class="btn" onclick="app.createFile()">Create</button>
        </div>
    </div>
</div>

<!-- Presentation Templates Modal -->
<div class="modal" id="templatesModal">
    <div class="modal-content" style="min-width:600px">
        <div class="modal-header">
            <div class="modal-title">üìã Presentation Templates</div>
            <button class="icon-btn" onclick="app.closeModal()">
                <svg class="icon"><use href="#icon-close"></use></svg>
            </button>
        </div>
        <div class="form-group">
            <label>Template:</label>
            <select id="templateSelect">
                <option value="basic">Basic Presentation</option>
                <option value="principles">7 Key Principles</option>
                <option value="timeline">Timeline & Gantt Charts</option>
                <option value="charts">Chart Examples</option>
            </select>
        </div>
        <div class="form-group">
            <label>Reveal.js Theme:</label>
            <select id="revealThemeSelect">
                <option value="black">Black (Default)</option>
                <option value="white">White</option>
                <option value="league">League</option>
                <option value="sky">Sky</option>
                <option value="beige">Beige</option>
                <option value="serif">Serif</option>
                <option value="simple">Simple</option>
                <option value="solarized">Solarized</option>
                <option value="night">Night</option>
                <option value="moon">Moon</option>
            </select>
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="app.closeModal()">Cancel</button>
            <button class="btn" onclick="app.applyTemplateAndSettings()">Apply</button>
        </div>
    </div>
</div>

<!-- Help Modal -->
<div class="modal" id="helpModal">
    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
        <div class="modal-header">
            <div class="modal-title">üí° Help & Complete Guide</div>
            <button class="icon-btn" onclick="app.closeModal()">
                <svg class="icon"><use href="#icon-close"></use></svg>
            </button>
        </div>

        <h2>üöÄ Welcome to MDNotes Pro v2.1.0</h2>
        <p>A professional, production-ready markdown editor with advanced presentation, visualization, and file management capabilities.</p>

        <h2>üìÅ File Management (Notion-style)</h2>
        <h3>Organizing Files</h3>
        <ul>
            <li><b>Create Folders:</b> Click ‚ûï on any folder to create subfolders</li>
            <li><b>Move Files:</b> Drag and drop files into folders</li>
            <li><b>Rename/Delete:</b> Use ‚úèÔ∏è and üóëÔ∏è buttons on folders</li>
            <li><b>Expand/Collapse:</b> Click ‚ñ∂/‚ñº to toggle folder visibility</li>
        </ul>
        <h3>Tags & Organization</h3>
        <ul>
            <li><b>Add Tags:</b> Click üè∑Ô∏è on any file to add color-coded tags</li>
            <li><b>Favorites:</b> Click ‚òÜ to mark important files (shows ‚≠ê)</li>
            <li><b>Archive:</b> Click üì¶ to archive old files</li>
            <li><b>Search:</b> Use the search box to find files by name, content, or tags</li>
        </ul>

        <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
        <table style="width:100%; margin:10px 0;">
            <tr><td><kbd>Ctrl/Cmd + S</kbd></td><td>Save current file</td></tr>
            <tr><td><kbd>Ctrl/Cmd + N</kbd></td><td>Create new file</td></tr>
            <tr><td><kbd>Ctrl/Cmd + B</kbd></td><td>Bold text</td></tr>
            <tr><td><kbd>Ctrl/Cmd + I</kbd></td><td>Italic text</td></tr>
            <tr><td><kbd>Ctrl/Cmd + K</kbd></td><td>Insert link</td></tr>
            <tr><td><kbd>F11</kbd></td><td>Toggle fullscreen</td></tr>
        </table>

        <h2>üìù Markdown Syntax Guide</h2>
        <h3>Text Formatting</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
# Heading 1
## Heading 2
### Heading 3

**bold text**
*italic text*
***bold and italic***
~~strikethrough~~
`inline code`

> Blockquote
> Multiple lines</pre>

        <h3>Lists</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
Unordered list:
- Item 1
- Item 2
  - Nested item

Ordered list:
1. First item
2. Second item
3. Third item

Task list:
- [ ] Todo item
- [x] Completed item</pre>

        <h3>Links & Images</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
[Link text](https://example.com)
![Image alt text](image-url.jpg)
[Link with title](url "Title on hover")</pre>

        <h3>Tables</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Data A   | Data B   | Data C   |

‚ú® Tables are interactive! Click headers to sort,
use filter box to search, export to CSV.</pre>

        <h3>Code Blocks</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```javascript
function hello() {
    console.log("Hello World!");
}
```

Supports: javascript, python, java, cpp, html,
css, sql, bash, and many more languages.</pre>

        <h2>üìä Mermaid Diagrams</h2>
        <h3>Flowchart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```mermaid
graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Action 1]
    B -->|No| D[Action 2]
    C --> E[End]
    D --> E
```</pre>

        <h3>Sequence Diagram</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```mermaid
sequenceDiagram
    Alice->>John: Hello John!
    John-->>Alice: Hi Alice!
    Alice->>John: How are you?
```</pre>

        <h3>Gantt Chart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```mermaid
gantt
    title Project Timeline
    dateFormat YYYY-MM-DD
    section Phase 1
    Design      :done, 2024-01-01, 30d
    Development :active, 2024-02-01, 60d
    section Phase 2
    Testing     :2024-04-01, 20d
    Deployment  :2024-04-21, 10d
```</pre>

        <h3>Pie Chart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```mermaid
pie title Market Share
    "Product A" : 42
    "Product B" : 28
    "Product C" : 30
```</pre>

        <h2>üìà Chart.js Visualizations</h2>
        <h3>Bar Chart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```chart
{
  "type": "bar",
  "data": {
    "labels": ["Q1", "Q2", "Q3", "Q4"],
    "datasets": [{
      "label": "Sales 2024",
      "data": [12, 19, 15, 25],
      "backgroundColor": "#007acc"
    }]
  }
}
```</pre>

        <h3>Line Chart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```chart
{
  "type": "line",
  "data": {
    "labels": ["Jan", "Feb", "Mar", "Apr"],
    "datasets": [{
      "label": "Revenue",
      "data": [65, 72, 81, 89],
      "borderColor": "#4ECDC4",
      "fill": false
    }]
  }
}
```</pre>

        <h3>Pie/Doughnut Chart</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```chart
{
  "type": "pie",
  "data": {
    "labels": ["Red", "Blue", "Yellow"],
    "datasets": [{
      "data": [300, 50, 100],
      "backgroundColor": ["#FF6384", "#36A2EB", "#FFCE56"]
    }]
  }
}
```

Types: bar, line, pie, doughnut, radar, polarArea</pre>

        <h2>üìÖ Timeline Visualization (Timesheet.js)</h2>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
```timesheet
{
  "sections": [
    {
      "name": "Development",
      "events": [
        {
          "name": "Backend API",
          "start": "2024-01-01",
          "end": "2024-03-01"
        },
        {
          "name": "Frontend UI",
          "start": "2024-02-01",
          "end": "2024-04-01"
        }
      ]
    },
    {
      "name": "Design",
      "events": [
        {
          "name": "Wireframes",
          "start": "2024-01-01",
          "end": "2024-01-15"
        }
      ]
    }
  ]
}
```</pre>

        <h2>üéØ Interactive Features</h2>
        <h3>‚úÖ Task Lists</h3>
        <p>Create interactive checkboxes with progress tracking:</p>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
- [ ] Task 1
- [x] Task 2 (completed)
- [ ] Task 3

‚ú® Click checkboxes in preview to toggle!
Shows progress bars automatically.</pre>

        <h3>üìä Interactive Tables</h3>
        <ul>
            <li><b>Sort:</b> Click column headers to sort (asc/desc/none)</li>
            <li><b>Filter:</b> Use search box to filter rows</li>
            <li><b>Export:</b> Click export button to save as CSV</li>
        </ul>

        <h3>üîÑ Bidirectional Editing</h3>
        <ul>
            <li>Click any heading, paragraph, or list in <b>Preview</b></li>
            <li>Editor automatically jumps to that line</li>
            <li>Visual highlight shows the location</li>
        </ul>

        <h3>üß† Mindmap Focus</h3>
        <ul>
            <li>Mindmap shows document structure as interactive diagram</li>
            <li>Click nodes to explore nested content</li>
            <li>Toggle focus mode to highlight active section</li>
            <li>Export as SVG or PNG</li>
        </ul>

        <h2>üé§ Presentation Mode</h2>
        <h3>Creating Slides</h3>
        <pre style="background: var(--bg-secondary); padding: 10px; border-radius: 4px;">
---
theme: black
---

# Slide 1 Title

Content here...

---

## Slide 2

- Point 1
- Point 2

---

## Slide 3

More content...</pre>
        <p><b>Separator:</b> Use <code>---</code> to split slides</p>
        <p><b>Themes:</b> black, white, league, sky, beige, serif, simple, solarized, night, moon</p>
        <p><b>Navigation:</b> Arrow keys, space bar, or on-screen controls</p>

        <h2>üíæ Export Formats</h2>
        <table style="width:100%; margin:10px 0;">
            <tr><td><b>Markdown (.md)</b></td><td>Plain text format</td></tr>
            <tr><td><b>HTML</b></td><td>Standalone web page with styles</td></tr>
            <tr><td><b>PDF (Preview)</b></td><td>Multi-page document from preview</td></tr>
            <tr><td><b>PDF (Slides)</b></td><td>One slide per page</td></tr>
            <tr><td><b>PowerPoint (.pptx)</b></td><td>Editable presentation</td></tr>
            <tr><td><b>DOCX</b></td><td>Word document format</td></tr>
            <tr><td><b>CSV</b></td><td>From interactive tables</td></tr>
        </table>

        <h2>üé® Themes</h2>
        <ul>
            <li><b>Dark:</b> Professional dark mode (VS Code style)</li>
            <li><b>Light:</b> Clean light theme</li>
            <li><b>Dracula:</b> Popular dark color scheme</li>
            <li><b>Nord:</b> Arctic-inspired palette</li>
            <li><b>Monokai:</b> Classic code editor theme</li>
        </ul>

        <h2>üí° Pro Tips</h2>
        <ul>
            <li>Use <b>Ctrl+S</b> frequently to save your work</li>
            <li>Organize files with folders and tags from the start</li>
            <li>Create presentation templates for reuse</li>
            <li>Use bidirectional editing to navigate large documents</li>
            <li>Export mindmaps as images for documentation</li>
            <li>Interactive tables work great with data from spreadsheets</li>
            <li>Use task lists for project management</li>
            <li>Fullscreen mode works on all panels (F11)</li>
        </ul>

        <h2>üîó Resources</h2>
        <ul>
            <li><a href="https://www.markdownguide.org/" target="_blank">Markdown Guide</a></li>
            <li><a href="https://mermaid.js.org/" target="_blank">Mermaid Documentation</a></li>
            <li><a href="https://www.chartjs.org/" target="_blank">Chart.js Documentation</a></li>
            <li><a href="https://revealjs.com/" target="_blank">Reveal.js (Presentations)</a></li>
        </ul>

        <div class="modal-actions">
            <button class="btn" onclick="app.closeModal()">Close</button>
        </div>
    </div>
</div>


    <!-- Loading Spinner -->
    <div class="spinner-overlay" id="spinnerOverlay">
        <div class="spinner"></div>
        <span id="spinnerText">Loading...</span>
    </div>

    <!-- SVG Icon Sprite Sheet -->
<svg width="0" height="0" style="position:absolute; display:none;">
    <defs>
        <symbol id="icon-folder" viewBox="0 0 24 24">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
        </symbol>
        <symbol id="icon-edit" viewBox="0 0 24 24">
            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
        </symbol>
        <symbol id="icon-eye" viewBox="0 0 24 24">
            <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
            <circle cx="12" cy="12" r="3"></circle>
        </symbol>
        <symbol id="icon-git-branch" viewBox="0 0 24 24">
            <line x1="6" y1="3" x2="6" y2="15"></line>
            <circle cx="18" cy="6" r="3"></circle>
            <circle cx="6" cy="18" r="3"></circle>
            <path d="M18 9a9 9 0 0 1-9 9"></path>
        </symbol>
        <symbol id="icon-save" viewBox="0 0 24 24">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
        </symbol>
        <symbol id="icon-download" viewBox="0 0 24 24">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </symbol>
        <symbol id="icon-play" viewBox="0 0 24 24">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
        </symbol>
        <symbol id="icon-sliders" viewBox="0 0 24 24">
            <line x1="4" y1="21" x2="4" y2="14"></line>
            <line x1="4" y1="10" x2="4" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="12"></line>
            <line x1="12" y1="8" x2="12" y2="3"></line>
            <line x1="20" y1="21" x2="20" y2="16"></line>
            <line x1="20" y1="12" x2="20" y2="3"></line>
            <line x1="1" y1="14" x2="7" y2="14"></line>
            <line x1="9" y1="8" x2="15" y2="8"></line>
            <line x1="17" y1="16" x2="23" y2="16"></line>
        </symbol>
        <symbol id="icon-settings" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </symbol>
        <symbol id="icon-help" viewBox="0 0 24 24">
            <circle cx="12" cy="12" r="10"></circle>
            <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
            <line x1="12" y1="17" x2="12.01" y2="17"></line>
        </symbol>
        <symbol id="icon-close" viewBox="0 0 24 24">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </symbol>
        <symbol id="icon-trash" viewBox="0 0 24 24">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </symbol>
        <symbol id="icon-maximize" viewBox="0 0 24 24">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>
        </symbol>
        <symbol id="icon-minimize" viewBox="0 0 24 24">
            <path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>
        </symbol>
        <symbol id="icon-bold" viewBox="0 0 24 24">
            <path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
            <path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>
        </symbol>
        <symbol id="icon-italic" viewBox="0 0 24 24">
            <line x1="19" y1="4" x2="10" y2="4"></line>
            <line x1="14" y1="20" x2="5" y2="20"></line>
            <line x1="15" y1="4" x2="9" y2="20"></line>
        </symbol>
        <symbol id="icon-code" viewBox="0 0 24 24">
            <polyline points="16 18 22 12 16 6"></polyline>
            <polyline points="8 6 2 12 8 18"></polyline>
        </symbol>
        <symbol id="icon-quote" viewBox="0 0 24 24">
            <path d="M3 21c3 0 7-1 7-8V5c0-1.25-.756-2-2-2H4c-1.25 0-2 .75-2 2v8c0 1.25.75 2 2 2h2"></path>
            <path d="M14 21c3 0 7-1 7-8V5c0-1.25-.75-2-2-2h-4c-1.25 0-2 .75-2 2v8c0 1.25.75 2 2 2h2"></path>
        </symbol>
        <symbol id="icon-list" viewBox="0 0 24 24">
            <line x1="8" y1="6" x2="21" y2="6"></line>
            <line x1="8" y1="12" x2="21" y2="12"></line>
            <line x1="8" y1="18" x2="21" y2="18"></line>
            <line x1="3" y1="6" x2="3.01" y2="6"></line>
            <line x1="3" y1="12" x2="3.01" y2="12"></line>
            <line x1="3" y1="18" x2="3.01" y2="18"></line>
        </symbol>
        <symbol id="icon-ol" viewBox="0 0 24 24">
            <line x1="10" y1="6" x2="21" y2="6"></line>
            <line x1="10" y1="12" x2="21" y2="12"></line>
            <line x1="10" y1="18" x2="21" y2="18"></line>
            <path d="M4 6h1v4"></path>
            <path d="M4 10h2"></path>
            <path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path>
        </symbol>
        <symbol id="icon-check-square" viewBox="0 0 24 24">
            <polyline points="9 11 12 14 22 4"></polyline>
            <path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>
        </symbol>
        <symbol id="icon-link" viewBox="0 0 24 24">
            <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
            <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
        </symbol>
        <symbol id="icon-image" viewBox="0 0 24 24">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <circle cx="8.5" cy="8.5" r="1.5"></circle>
            <polyline points="21 15 16 10 5 21"></polyline>
        </symbol>
        <symbol id="icon-code-block" viewBox="0 0 24 24">
            <polyline points="16 18 22 12 16 6"></polyline>
            <polyline points="8 6 2 12 8 18"></polyline>
        </symbol>
        <symbol id="icon-file-text" viewBox="0 0 24 24">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
            <polyline points="14 2 14 8 20 8"></polyline>
            <line x1="16" y1="13" x2="8" y2="13"></line>
            <line x1="16" y1="17" x2="8" y2="17"></line>
            <polyline points="10 9 9 9 8 9"></polyline>
        </symbol>
        <symbol id="icon-file" viewBox="0 0 24 24">
            <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path>
            <polyline points="13 2 13 9 20 9"></polyline>
        </symbol>
        <symbol id="icon-presentation" viewBox="0 0 24 24">
            <path d="M2 3h20"></path>
            <path d="M21 3v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V3"></path>
            <path d="M7 21l5-5 5 5"></path>
        </symbol>
    </defs>
</svg>


    <!-- External JavaScript Libraries -->
    <!-- Dexie.js for IndexedDB (Block Editor) -->
    <script src="https://cdn.jsdelivr.net/npm/dexie@3/dist/dexie.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/markmap-autoloader"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/plugin/markdown/markdown.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked-gfm-heading-id/lib/index.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked-highlight/lib/index.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
    <script src="https://unpkg.com/docx@8.5.0/build/index.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/mode/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/edit/closebrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/selection/active-line.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/search/match-highlighter.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/addon/scroll/annotatescrollbar.min.js"></script>

    <!-- Application JavaScript (ES6 Modules) -->
    <script type="module">
        /**
 * Storage Module - Handles localStorage operations
 */
const Storage = {
    keys: {
        files: 'mdnotes_files',
        settings: 'mdnotes_settings_v2'
    },

    /**
     * Load files from localStorage
     */
    loadFiles() {
        try {
            const data = localStorage.getItem(this.keys.files);
            return data ? JSON.parse(data) : {};
        } catch (e) {
            console.error('Failed to load files:', e);
            return {};
        }
    },

    /**
     * Save files to localStorage
     */
    saveFiles(files) {
        try {
            localStorage.setItem(this.keys.files, JSON.stringify(files));
            return true;
        } catch (e) {
            console.error('Failed to save files:', e);
            return false;
        }
    },

    /**
     * Load settings from localStorage
     */
    loadSettings() {
        try {
            const data = localStorage.getItem(this.keys.settings);
            return data ? JSON.parse(data) : null;
        } catch (e) {
            console.error('Failed to load settings:', e);
            return null;
        }
    },

    /**
     * Save settings to localStorage
     */
    saveSettings(settings) {
        try {
            localStorage.setItem(this.keys.settings, JSON.stringify(settings));
            return true;
        } catch (e) {
            console.error('Failed to save settings:', e);
            return false;
        }
    },

    /**
     * Clear all storage
     */
    clear() {
        try {
            localStorage.removeItem(this.keys.files);
            localStorage.removeItem(this.keys.settings);
            return true;
        } catch (e) {
            console.error('Failed to clear storage:', e);
            return false;
        }
    },

    /**
     * Get storage usage info
     */
    getStorageInfo() {
        let total = 0;
        for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
                total += localStorage[key].length + key.length;
            }
        }
        return {
            used: total,
            usedKB: (total / 1024).toFixed(2),
            usedMB: (total / (1024 * 1024)).toFixed(2)
        };
    }
};


/**
 * Theme Module - Handles theme management
 */
const Theme = {
    themes: {
        dark: {
            '--bg-primary': '#1e1e1e',
            '--bg-secondary': '#252526',
            '--bg-tertiary': '#2d2d30',
            '--text-primary': '#d4d4d4',
            '--text-secondary': '#808080',
            '--border': '#3e3e42',
            '--accent': '#007acc'
        },
        light: {
            '--bg-primary': '#fff',
            '--bg-secondary': '#f0f0f0',
            '--bg-tertiary': '#e0e0e0',
            '--text-primary': '#000',
            '--text-secondary': '#666',
            '--border': '#ccc',
            '--accent': '#0066cc'
        },
        dracula: {
            '--bg-primary': '#282a36',
            '--bg-secondary': '#1e1f29',
            '--bg-tertiary': '#44475a',
            '--text-primary': '#f8f8f2',
            '--text-secondary': '#6272a4',
            '--border': '#44475a',
            '--accent': '#bd93f9'
        },
        nord: {
            '--bg-primary': '#2e3440',
            '--bg-secondary': '#3b4252',
            '--bg-tertiary': '#434c5e',
            '--text-primary': '#eceff4',
            '--text-secondary': '#d8dee9',
            '--border': '#4c566a',
            '--accent': '#88c0d0'
        },
        monokai: {
            '--bg-primary': '#272822',
            '--bg-secondary': '#1e1f1c',
            '--bg-tertiary': '#3e3d32',
            '--text-primary': '#f8f8f2',
            '--text-secondary': '#75715e',
            '--border': '#3e3d32',
            '--accent': '#66d9ef'
        }
    },

    currentTheme: 'dark',

    /**
     * Apply a theme
     */
    apply(themeName) {
        const theme = this.themes[themeName];
        if (!theme) {
            console.warn(`Theme '${themeName}' not found`);
            return false;
        }

        // Apply CSS variables
        Object.keys(theme).forEach(key => {
            document.documentElement.style.setProperty(key, theme[key]);
        });

        // Update data attribute
        document.documentElement.setAttribute('data-theme', themeName);

        this.currentTheme = themeName;

        // Update theme presets
        document.querySelectorAll('.theme-preset').forEach(el => {
            el.classList.toggle('active', el.dataset.theme === themeName);
        });

        // Sync Mermaid theme
        if (window.mermaid) {
            const mermaidTheme = (themeName === 'light') ? 'default' : 'dark';
            window.mermaid.initialize({ startOnLoad: false, theme: mermaidTheme });
        }

        return true;
    },

    /**
     * Get current theme name
     */
    getCurrent() {
        return this.currentTheme;
    },

    /**
     * Get all available themes
     */
    getAll() {
        return Object.keys(this.themes);
    }
};


/**
 * File Manager Module - Handles file operations
 */
class FileManager {
    constructor(storage) {
        this.storage = storage;
        this.files = {};
        this.currentFile = null;
        this.onFileChange = null; // Callback when file changes
    }

    /**
     * Initialize file manager
     */
    init() {
        this.files = this.storage.loadFiles();

        // Create welcome file if no files exist
        if (Object.keys(this.files).length === 0) {
            this.createWelcomeFile();
        }

        this.currentFile = Object.keys(this.files)[0];
        this.render();
    }

    /**
     * Create welcome file
     */
    createWelcomeFile() {
        this.files['welcome.md'] = {
            name: 'welcome.md',
            content: `# Welcome to MDNotes Pro

## Features

- **Advanced Editor** with CodeMirror
- **Fullscreen Mode** for all panels
- **Professional Export** (MD, HTML, PDF, PPTX)
- **Presentation Themes** via Reveal.js
- **Mindmap Generation**
- **Diagram Support** (Mermaid, Charts, Timelines)

## Quick Start

1. Write your markdown in the **Editor** panel
2. Preview it in real-time
3. Generate mindmaps from headings
4. Create presentations with \`---\` separators
5. Export to multiple formats

## Diagram Examples

### Mermaid Flowchart
\`\`\`mermaid
graph TD
    A[Start] --> B{Decision}
    B -->|Yes| C[Success]
    B -->|No| D[Retry]
    D --> A
\`\`\`

### Gantt Timeline
\`\`\`mermaid
gantt
    title Project Timeline
    dateFormat YYYY-MM-DD
    section Phase 1
    Design :2024-01-01, 30d
    Development :2024-02-01, 60d
    section Phase 2
    Testing :2024-04-01, 30d
    Deployment :2024-05-01, 15d
\`\`\`

### Chart
\`\`\`chart
{
  "type": "bar",
  "data": {
    "labels": ["Q1", "Q2", "Q3", "Q4"],
    "datasets": [{
      "label": "Revenue",
      "data": [12, 19, 15, 25]
    }]
  }
}
\`\`\`

---

**Happy editing!** üöÄ
`,
            modified: Date.now()
        };
    }

    /**
     * Render file list
     */
    render() {
        const list = document.getElementById('fileList');
        if (!list) return;

        list.innerHTML = '';

        Object.values(this.files).forEach(file => {
            const item = document.createElement('div');
            item.className = 'file-item' + (file.name === this.currentFile ? ' active' : '');
            item.innerHTML = `
                <span>${file.name}</span>
                <button class="delete-btn" title="Delete file">
                    <svg class="icon" style="width:14px; height:14px"><use href="#icon-trash"></use></svg>
                </button>
            `;

            item.querySelector('span').onclick = () => this.switchFile(file.name);
            item.querySelector('.delete-btn').onclick = (e) => {
                e.stopPropagation();
                this.deleteFile(file.name);
            };

            list.appendChild(item);
        });
    }

    /**
     * Switch to a different file
     */
    switchFile(filename) {
        if (filename === this.currentFile) return;

        this.currentFile = filename;
        this.render();

        if (this.onFileChange) {
            this.onFileChange(this.files[filename]);
        }
    }

    /**
     * Get current file
     */
    getCurrentFile() {
        return this.files[this.currentFile];
    }

    /**
     * Save current file content
     */
    saveCurrentFile(content) {
        if (!this.currentFile) return false;

        this.files[this.currentFile].content = content;
        this.files[this.currentFile].modified = Date.now();
        this.storage.saveFiles(this.files);

        return true;
    }

    /**
     * Create new file
     */
    createFile(filename, content = '') {
        if (!filename) {
            throw new Error('Filename is required');
        }

        if (!filename.endsWith('.md')) {
            filename += '.md';
        }

        if (this.files[filename]) {
            throw new Error('File already exists');
        }

        this.files[filename] = {
            name: filename,
            content: content || `# ${filename.replace('.md', '')}`,
            modified: Date.now()
        };

        this.currentFile = filename;
        this.storage.saveFiles(this.files);
        this.render();

        if (this.onFileChange) {
            this.onFileChange(this.files[filename]);
        }

        return true;
    }

    /**
     * Delete file
     */
    deleteFile(filename) {
        if (!confirm(`Delete ${filename}?`)) return false;

        delete this.files[filename];

        if (this.currentFile === filename) {
            const keys = Object.keys(this.files);
            this.currentFile = keys.length ? keys[0] : null;
        }

        this.storage.saveFiles(this.files);
        this.render();

        if (this.currentFile && this.onFileChange) {
            this.onFileChange(this.files[this.currentFile]);
        }

        return true;
    }

    /**
     * Load external files
     */
    loadExternalFiles(fileList) {
        Array.from(fileList).forEach(file => {
            const reader = new FileReader();
            reader.onload = (e) => {
                this.files[file.name] = {
                    name: file.name,
                    content: e.target.result,
                    modified: Date.now()
                };
                this.currentFile = file.name;
                this.storage.saveFiles(this.files);
                this.render();

                if (this.onFileChange) {
                    this.onFileChange(this.files[file.name]);
                }
            };
            reader.readAsText(file);
        });
    }

    /**
     * Toggle file manager visibility
     */
    toggleVisibility() {
        const fm = document.getElementById('fileManager');
        if (fm) {
            fm.classList.toggle('hidden');
        }
    }

    /**
     * Get all files
     */
    getAllFiles() {
        return this.files;
    }
}


/**
 * Advanced File System - Notion-like hierarchical file management
 * Supports folders, tags, nested structure, drag & drop
 */
class AdvancedFileSystem {
    constructor(storage) {
        this.storage = storage;
        this.files = {};
        this.folders = {};
        this.tags = {};
        this.currentFile = null;
        this.currentFolder = null;
        this.onFileChange = null;
    }

    /**
     * Initialize file system
     */
    init() {
        this.loadData();
        this.render();
    }

    /**
     * Load data from storage
     */
    loadData() {
        // Load files
        const filesData = this.storage.loadFiles();

        // Convert old format to new format if needed
        Object.keys(filesData).forEach(key => {
            if (!filesData[key].metadata) {
                filesData[key] = this.migrateToNewFormat(filesData[key]);
            }
        });

        this.files = filesData;

        // Load folders
        try {
            const foldersData = localStorage.getItem('mdnotes_folders');
            this.folders = foldersData ? JSON.parse(foldersData) : this.createDefaultFolders();
        } catch (e) {
            this.folders = this.createDefaultFolders();
        }

        // Load tags
        try {
            const tagsData = localStorage.getItem('mdnotes_tags');
            this.tags = tagsData ? JSON.parse(tagsData) : {};
        } catch (e) {
            this.tags = {};
        }
    }

    /**
     * Create default folder structure
     */
    createDefaultFolders() {
        return {
            root: {
                id: 'root',
                name: 'All Files',
                parent: null,
                children: [],
                expanded: true,
                icon: 'üìÅ'
            }
        };
    }

    /**
     * Migrate old file format to new format
     */
    migrateToNewFormat(oldFile) {
        return {
            ...oldFile,
            metadata: {
                folder: 'root',
                tags: [],
                created: oldFile.modified || Date.now(),
                modified: oldFile.modified || Date.now(),
                favorite: false,
                archived: false,
                color: null
            }
        };
    }

    /**
     * Save all data
     */
    saveData() {
        this.storage.saveFiles(this.files);
        localStorage.setItem('mdnotes_folders', JSON.stringify(this.folders));
        localStorage.setItem('mdnotes_tags', JSON.stringify(this.tags));
    }

    /**
     * Create new folder
     */
    createFolder(name, parentId = 'root') {
        const id = 'folder_' + Date.now();
        const folder = {
            id,
            name,
            parent: parentId,
            children: [],
            expanded: true,
            icon: 'üìÅ'
        };

        this.folders[id] = folder;

        // Add to parent's children
        if (this.folders[parentId]) {
            this.folders[parentId].children.push(id);
        }

        this.saveData();
        this.render();
        return id;
    }

    /**
     * Rename folder
     */
    renameFolder(folderId, newName) {
        if (this.folders[folderId]) {
            this.folders[folderId].name = newName;
            this.saveData();
            this.render();
        }
    }

    /**
     * Delete folder
     */
    deleteFolder(folderId) {
        if (folderId === 'root') return false;

        const folder = this.folders[folderId];
        if (!folder) return false;

        // Move files to parent folder
        Object.keys(this.files).forEach(key => {
            if (this.files[key].metadata.folder === folderId) {
                this.files[key].metadata.folder = folder.parent || 'root';
            }
        });

        // Move subfolders to parent
        folder.children.forEach(childId => {
            if (this.folders[childId]) {
                this.folders[childId].parent = folder.parent || 'root';
                this.folders[folder.parent || 'root'].children.push(childId);
            }
        });

        // Remove from parent's children
        if (folder.parent && this.folders[folder.parent]) {
            this.folders[folder.parent].children = this.folders[folder.parent].children.filter(id => id !== folderId);
        }

        delete this.folders[folderId];
        this.saveData();
        this.render();
        return true;
    }

    /**
     * Move file to folder
     */
    moveFile(filename, folderId) {
        if (this.files[filename]) {
            this.files[filename].metadata.folder = folderId;
            this.saveData();
            this.render();
        }
    }

    /**
     * Add tag to file
     */
    addTag(filename, tagName) {
        if (!this.files[filename]) return;

        const tags = this.files[filename].metadata.tags || [];
        if (!tags.includes(tagName)) {
            tags.push(tagName);
            this.files[filename].metadata.tags = tags;

            // Track tag usage
            if (!this.tags[tagName]) {
                this.tags[tagName] = { count: 0, color: this.generateTagColor() };
            }
            this.tags[tagName].count++;

            this.saveData();
            this.render();
        }
    }

    /**
     * Remove tag from file
     */
    removeTag(filename, tagName) {
        if (!this.files[filename]) return;

        const tags = this.files[filename].metadata.tags || [];
        const index = tags.indexOf(tagName);
        if (index > -1) {
            tags.splice(index, 1);
            this.files[filename].metadata.tags = tags;

            // Update tag count
            if (this.tags[tagName]) {
                this.tags[tagName].count--;
                if (this.tags[tagName].count <= 0) {
                    delete this.tags[tagName];
                }
            }

            this.saveData();
            this.render();
        }
    }

    /**
     * Generate random tag color
     */
    generateTagColor() {
        const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
        return colors[Math.floor(Math.random() * colors.length)];
    }

    /**
     * Toggle favorite
     */
    toggleFavorite(filename) {
        if (this.files[filename]) {
            this.files[filename].metadata.favorite = !this.files[filename].metadata.favorite;
            this.saveData();
            this.render();
        }
    }

    /**
     * Toggle archive
     */
    toggleArchive(filename) {
        if (this.files[filename]) {
            this.files[filename].metadata.archived = !this.files[filename].metadata.archived;
            this.saveData();
            this.render();
        }
    }

    /**
     * Search files
     */
    searchFiles(query) {
        query = query.toLowerCase();
        return Object.values(this.files).filter(file => {
            return file.name.toLowerCase().includes(query) ||
                   file.content.toLowerCase().includes(query) ||
                   (file.metadata.tags && file.metadata.tags.some(tag => tag.toLowerCase().includes(query)));
        });
    }

    /**
     * Filter files by criteria
     */
    filterFiles(criteria) {
        return Object.values(this.files).filter(file => {
            if (criteria.folder && file.metadata.folder !== criteria.folder) return false;
            if (criteria.tag && !file.metadata.tags?.includes(criteria.tag)) return false;
            if (criteria.favorite && !file.metadata.favorite) return false;
            if (criteria.archived !== undefined && file.metadata.archived !== criteria.archived) return false;
            return true;
        });
    }

    /**
     * Get folder tree
     */
    getFolderTree(folderId = 'root', level = 0) {
        const folder = this.folders[folderId];
        if (!folder) return null;

        return {
            ...folder,
            level,
            children: folder.children.map(childId => this.getFolderTree(childId, level + 1)).filter(Boolean)
        };
    }

    /**
     * Render file system UI
     */
    render() {
        const container = document.getElementById('fileList');
        if (!container) return;

        container.innerHTML = '';

        // Render folder tree
        const tree = this.getFolderTree();
        this.renderFolderNode(tree, container);
    }

    /**
     * Render folder node recursively
     */
    renderFolderNode(node, container) {
        if (!node) return;

        // Folder element
        const folderEl = document.createElement('div');
        folderEl.className = 'folder-item';
        folderEl.style.paddingLeft = `${node.level * 15}px`;
        folderEl.dataset.folderId = node.id;
        folderEl.innerHTML = `
            <span class="folder-toggle">${node.expanded ? '‚ñº' : '‚ñ∂'}</span>
            <span class="folder-icon">${node.icon}</span>
            <span class="folder-name">${node.name}</span>
            <span class="folder-count">(${this.getFileCount(node.id)})</span>
            <div class="folder-actions">
                ${node.id !== 'root' ? '<button class="action-btn" data-action="rename" title="Rename">‚úèÔ∏è</button>' : ''}
                ${node.id !== 'root' ? '<button class="action-btn" data-action="delete" title="Delete">üóëÔ∏è</button>' : ''}
                <button class="action-btn" data-action="add" title="Add Subfolder">‚ûï</button>
            </div>
        `;

        // Toggle expansion
        folderEl.querySelector('.folder-toggle').onclick = () => {
            node.expanded = !node.expanded;
            this.saveData();
            this.render();
        };

        // Actions
        folderEl.querySelectorAll('.action-btn').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                const action = btn.dataset.action;
                if (action === 'add') this.showAddFolderDialog(node.id);
                if (action === 'rename') this.showRenameFolderDialog(node.id);
                if (action === 'delete') this.confirmDeleteFolder(node.id);
            };
        });

        // Drag & drop for folders
        let dragCounter = 0; // Counter to handle dragleave properly

        folderEl.ondragenter = (e) => {
            e.preventDefault();
            dragCounter++;

            // Check if we're dragging this folder onto itself
            const sourceFolderId = e.dataTransfer.types.includes('folderId')
                ? folderEl.dataset.folderId
                : null;

            if (sourceFolderId !== node.id) {
                folderEl.classList.add('drag-over');
            }
        };

        folderEl.ondragover = (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        };

        folderEl.ondragleave = (e) => {
            dragCounter--;
            if (dragCounter === 0) {
                folderEl.classList.remove('drag-over');
            }
        };

        folderEl.ondrop = (e) => {
            e.preventDefault();
            e.stopPropagation();
            dragCounter = 0;
            folderEl.classList.remove('drag-over');

            const filename = e.dataTransfer.getData('filename');
            const sourceFolderId = e.dataTransfer.getData('folderId');

            if (filename) {
                // Moving a file
                this.moveFileWithFeedback(filename, node.id);
            } else if (sourceFolderId && sourceFolderId !== node.id) {
                // Moving a folder
                this.moveFolderToFolder(sourceFolderId, node.id);
            }
        };

        // Make folders draggable (except root)
        if (node.id !== 'root') {
            folderEl.draggable = true;
            folderEl.ondragstart = (e) => {
                e.dataTransfer.setData('folderId', node.id);
                e.dataTransfer.effectAllowed = 'move';
                folderEl.classList.add('dragging');
            };

            folderEl.ondragend = (e) => {
                folderEl.classList.remove('dragging');
            };
        }

        container.appendChild(folderEl);

        // Render files in this folder
        if (node.expanded) {
            const filesInFolder = this.filterFiles({ folder: node.id, archived: false });
            filesInFolder.forEach(file => {
                const fileEl = this.renderFileItem(file, node.level + 1);
                container.appendChild(fileEl);
            });

            // Render child folders
            node.children.forEach(childNode => {
                this.renderFolderNode(childNode, container);
            });
        }
    }

    /**
     * Render file item
     */
    renderFileItem(file, level) {
        const fileEl = document.createElement('div');
        fileEl.className = 'file-item' + (file.name === this.currentFile ? ' active' : '');
        fileEl.style.paddingLeft = `${level * 15}px`;
        fileEl.draggable = true;
        fileEl.dataset.filename = file.name;

        const tags = file.metadata.tags || [];
        const tagsHTML = tags.map(tag =>
            `<span class="file-tag" style="background:${this.tags[tag]?.color || '#999'}">${tag}</span>`
        ).join('');

        fileEl.innerHTML = `
            <span class="file-icon">${file.metadata.favorite ? '‚≠ê' : 'üìÑ'}</span>
            <span class="file-name">${file.name}</span>
            ${tagsHTML}
            <div class="file-actions">
                <button class="action-btn" data-action="move" title="Move">üìÅ</button>
                <button class="action-btn" data-action="favorite" title="Favorite">${file.metadata.favorite ? '‚òÖ' : '‚òÜ'}</button>
                <button class="action-btn" data-action="tag" title="Add Tag">üè∑Ô∏è</button>
                <button class="action-btn" data-action="archive" title="Archive">üì¶</button>
                <button class="action-btn" data-action="delete" title="Delete">üóëÔ∏è</button>
            </div>
        `;

        // Click to open
        fileEl.querySelector('.file-name').onclick = () => this.switchFile(file.name);

        // Actions
        fileEl.querySelectorAll('.action-btn').forEach(btn => {
            btn.onclick = (e) => {
                e.stopPropagation();
                const action = btn.dataset.action;
                if (action === 'move') this.showMoveFileDialog(file.name);
                if (action === 'favorite') this.toggleFavorite(file.name);
                if (action === 'tag') this.showAddTagDialog(file.name);
                if (action === 'archive') this.toggleArchive(file.name);
                if (action === 'delete') this.confirmDeleteFile(file.name);
            };
        });

        // Drag and drop with visual feedback
        fileEl.ondragstart = (e) => {
            e.dataTransfer.setData('filename', file.name);
            e.dataTransfer.effectAllowed = 'move';
            fileEl.classList.add('dragging');

            // Create drag image
            const dragImage = fileEl.cloneNode(true);
            dragImage.style.opacity = '0.5';
            document.body.appendChild(dragImage);
            e.dataTransfer.setDragImage(dragImage, 0, 0);
            setTimeout(() => dragImage.remove(), 0);
        };

        fileEl.ondragend = (e) => {
            fileEl.classList.remove('dragging');
        };

        return fileEl;
    }

    /**
     * Switch to file
     */
    switchFile(filename) {
        this.currentFile = filename;
        this.render();
        if (this.onFileChange) {
            this.onFileChange(this.files[filename]);
        }
    }

    /**
     * Delete file
     */
    deleteFile(filename) {
        if (!confirm(`Delete ${filename}?`)) return false;

        delete this.files[filename];

        if (this.currentFile === filename) {
            const keys = Object.keys(this.files);
            this.currentFile = keys.length ? keys[0] : null;
        }

        this.saveData();
        this.render();
        return true;
    }

    /**
     * Show dialogs (to be implemented with proper modals)
     */
    showAddFolderDialog(parentId) {
        const name = prompt('Folder name:');
        if (name) {
            this.createFolder(name, parentId);
        }
    }

    showRenameFolderDialog(folderId) {
        const currentName = this.folders[folderId].name;
        const newName = prompt('New folder name:', currentName);
        if (newName && newName !== currentName) {
            this.renameFolder(folderId, newName);
        }
    }

    showAddTagDialog(filename) {
        const tag = prompt('Tag name:');
        if (tag) {
            this.addTag(filename, tag);
        }
    }

    /**
     * Get current file
     */
    getCurrentFile() {
        return this.files[this.currentFile];
    }

    /**
     * Create file
     */
    createFile(filename, content = '', folderId = 'root') {
        if (!filename.endsWith('.md')) {
            filename += '.md';
        }

        if (this.files[filename]) {
            throw new Error('File already exists');
        }

        this.files[filename] = {
            name: filename,
            content: content || `# ${filename.replace('.md', '')}`,
            modified: Date.now(),
            metadata: {
                folder: folderId,
                tags: [],
                created: Date.now(),
                modified: Date.now(),
                favorite: false,
                archived: false,
                color: null
            }
        };

        this.currentFile = filename;
        this.saveData();
        this.render();

        if (this.onFileChange) {
            this.onFileChange(this.files[filename]);
        }

        return true;
    }

    /**
     * Save current file
     */
    saveCurrentFile(content) {
        if (!this.currentFile || !this.files[this.currentFile]) return false;

        this.files[this.currentFile].content = content;
        this.files[this.currentFile].modified = Date.now();
        this.files[this.currentFile].metadata.modified = Date.now();
        this.saveData();

        return true;
    }

    /**
     * Get all files
     */
    getAllFiles() {
        return this.files;
    }

    /**
     * Export folder structure
     */
    exportStructure() {
        return {
            files: this.files,
            folders: this.folders,
            tags: this.tags
        };
    }

    /**
     * Import folder structure
     */
    importStructure(data) {
        if (data.files) this.files = data.files;
        if (data.folders) this.folders = data.folders;
        if (data.tags) this.tags = data.tags;
        this.saveData();
        this.render();
    }

    /**
     * Get file count in folder
     */
    getFileCount(folderId) {
        return Object.values(this.files).filter(
            file => file.metadata.folder === folderId && !file.metadata.archived
        ).length;
    }

    /**
     * Move file with visual feedback
     */
    moveFileWithFeedback(filename, folderId) {
        if (!this.files[filename]) return;

        const oldFolder = this.files[filename].metadata.folder;
        if (oldFolder === folderId) return;

        this.moveFile(filename, folderId);

        // Show notification
        if (window.app && window.app.showNotification) {
            const folderName = this.folders[folderId]?.name || 'folder';
            window.app.showNotification(`Moved "${filename}" to ${folderName}`, 'success');
        }
    }

    /**
     * Move folder to another folder
     */
    moveFolderToFolder(sourceFolderId, targetFolderId) {
        if (sourceFolderId === targetFolderId) return;
        if (sourceFolderId === 'root' || targetFolderId === 'root') return;

        const sourceFolder = this.folders[sourceFolderId];
        if (!sourceFolder) return;

        // Check if target is a child of source (prevent circular reference)
        if (this.isDescendant(targetFolderId, sourceFolderId)) {
            if (window.app && window.app.showNotification) {
                window.app.showNotification('Cannot move folder into its own subfolder', 'error');
            }
            return;
        }

        // Remove from old parent
        if (sourceFolder.parent && this.folders[sourceFolder.parent]) {
            this.folders[sourceFolder.parent].children =
                this.folders[sourceFolder.parent].children.filter(id => id !== sourceFolderId);
        }

        // Add to new parent
        sourceFolder.parent = targetFolderId;
        if (!this.folders[targetFolderId].children.includes(sourceFolderId)) {
            this.folders[targetFolderId].children.push(sourceFolderId);
        }

        this.saveData();
        this.render();

        if (window.app && window.app.showNotification) {
            window.app.showNotification('Folder moved successfully', 'success');
        }
    }

    /**
     * Check if folder is descendant of another
     */
    isDescendant(folderId, potentialAncestorId) {
        let current = this.folders[folderId];
        while (current && current.parent) {
            if (current.parent === potentialAncestorId) {
                return true;
            }
            current = this.folders[current.parent];
        }
        return false;
    }

    /**
     * Confirm delete file with modern dialog
     */
    confirmDeleteFile(filename) {
        if (window.app && window.app.showConfirmDialog) {
            window.app.showConfirmDialog(
                'Delete File',
                `Are you sure you want to delete "${filename}"?`,
                () => this.deleteFile(filename)
            );
        } else {
            // Fallback to native confirm
            if (confirm(`Delete "${filename}"?`)) {
                this.deleteFile(filename);
            }
        }
    }

    /**
     * Confirm delete folder with modern dialog
     */
    confirmDeleteFolder(folderId) {
        if (folderId === 'root') return;

        const folder = this.folders[folderId];
        if (!folder) return;

        const fileCount = this.getFileCount(folderId);
        const message = fileCount > 0
            ? `Delete "${folder.name}"? It contains ${fileCount} file(s) that will be moved to parent folder.`
            : `Delete "${folder.name}"?`;

        if (window.app && window.app.showConfirmDialog) {
            window.app.showConfirmDialog(
                'Delete Folder',
                message,
                () => this.deleteFolder(folderId)
            );
        } else {
            // Fallback to native confirm
            if (confirm(message)) {
                this.deleteFolder(folderId);
            }
        }
    }

    /**
     * Show move file dialog
     */
    showMoveFileDialog(filename) {
        if (!this.files[filename]) return;

        // Create a simple modal with folder list
        const modal = document.createElement('div');
        modal.className = 'modal show';
        modal.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title">Move "${filename}"</div>
                    <button class="icon-btn" onclick="this.closest('.modal').remove()">‚úï</button>
                </div>
                <div class="form-group">
                    <label>Select destination folder:</label>
                    <div id="folderSelectList" style="max-height: 300px; overflow-y: auto;">
                        ${this.renderFolderSelectList()}
                    </div>
                </div>
                <div class="modal-actions">
                    <button class="btn" onclick="this.closest('.modal').remove()">Cancel</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Add click handlers to folders
        modal.querySelectorAll('.folder-select-item').forEach(item => {
            item.onclick = () => {
                const folderId = item.dataset.folderId;
                this.moveFileWithFeedback(filename, folderId);
                modal.remove();
            };
        });
    }

    /**
     * Render folder select list for move dialog
     */
    renderFolderSelectList(folderId = 'root', level = 0) {
        const folder = this.folders[folderId];
        if (!folder) return '';

        let html = `
            <div class="folder-select-item" data-folder-id="${folderId}"
                 style="padding-left: ${level * 20}px; padding: 8px; cursor: pointer; border-radius: 4px;">
                <span>${folder.icon || 'üìÅ'}</span>
                <span>${folder.name}</span>
            </div>
        `;

        // Render children
        folder.children.forEach(childId => {
            html += this.renderFolderSelectList(childId, level + 1);
        });

        return html;
    }
}


/**
 * Blocks Database - IndexedDB with Dexie.js
 * Notion-style block-based editor persistence
 *
 * Note: Requires Dexie.js to be loaded globally via CDN
 * <script src="https://cdn.jsdelivr.net/npm/dexie@3/dist/dexie.min.js"></script>
 */

// Function to create the BlocksDatabase class only when Dexie is available
function createBlocksDatabase() {
    if (typeof Dexie === 'undefined') {
        console.error('Dexie.js is not loaded! Cannot create BlocksDatabase.');
        return null;
    }

    class BlocksDatabase extends Dexie {
        constructor() {
            super('MDNotesBlocks');

            this.version(1).stores({
                pages: '++id, title, icon, coverImage, createdAt, updatedAt, isFavorite, parentId',
                blocks: '++id, pageId, type, content, properties, parentId, *childIds, position, createdAt, updatedAt'
            });

            // Type definitions for better IDE support
            this.pages = this.table('pages');
            this.blocks = this.table('blocks');
        }

    /**
     * Create a new page
     */
    async createPage(title = 'Untitled', parentId = null) {
        const now = Date.now();
        const pageId = await this.pages.add({
            title,
            icon: 'üìÑ',
            coverImage: null,
            createdAt: now,
            updatedAt: now,
            isFavorite: false,
            parentId
        });

        // Create initial empty block
        await this.createBlock(pageId, 'text', '', null, 0);

        return pageId;
    }

    /**
     * Create a new block
     */
    async createBlock(pageId, type = 'text', content = '', parentId = null, position = 0) {
        const now = Date.now();
        const blockId = await this.blocks.add({
            pageId,
            type,
            content,
            properties: {},
            parentId,
            childIds: [],
            position,
            createdAt: now,
            updatedAt: now
        });

        return blockId;
    }

    /**
     * Get all blocks for a page (root level only)
     */
    async getPageBlocks(pageId) {
        return await this.blocks
            .where({ pageId, parentId: null })
            .sortBy('position');
    }

    /**
     * Get all blocks for a page (including nested)
     */
    async getAllPageBlocks(pageId) {
        return await this.blocks
            .where('pageId')
            .equals(pageId)
            .sortBy('position');
    }

    /**
     * Get child blocks
     */
    async getChildBlocks(parentId) {
        return await this.blocks
            .where({ parentId })
            .sortBy('position');
    }

    /**
     * Update block content
     */
    async updateBlock(blockId, updates) {
        return await this.blocks.update(blockId, {
            ...updates,
            updatedAt: Date.now()
        });
    }

    /**
     * Update block content only
     */
    async updateBlockContent(blockId, content) {
        return await this.updateBlock(blockId, { content });
    }

    /**
     * Update block type
     */
    async updateBlockType(blockId, type) {
        return await this.updateBlock(blockId, { type });
    }

    /**
     * Delete block and its children
     */
    async deleteBlock(blockId) {
        const block = await this.blocks.get(blockId);
        if (!block) return false;

        // Delete children recursively
        if (block.childIds && block.childIds.length > 0) {
            for (const childId of block.childIds) {
                await this.deleteBlock(childId);
            }
        }

        // Remove from parent's childIds
        if (block.parentId) {
            const parent = await this.blocks.get(block.parentId);
            if (parent) {
                const updatedChildIds = parent.childIds.filter(id => id !== blockId);
                await this.blocks.update(block.parentId, { childIds: updatedChildIds });
            }
        }

        // Delete the block
        await this.blocks.delete(blockId);
        return true;
    }

    /**
     * Indent block (make it child of previous sibling)
     */
    async indentBlock(blockId) {
        const block = await this.blocks.get(blockId);
        if (!block) return false;

        // Find previous sibling
        const siblings = await this.blocks
            .where({ pageId: block.pageId, parentId: block.parentId })
            .sortBy('position');

        const currentIndex = siblings.findIndex(b => b.id === blockId);
        if (currentIndex <= 0) return false; // Can't indent if first

        const previousSibling = siblings[currentIndex - 1];

        // Add to previous sibling's children
        const updatedChildIds = [...(previousSibling.childIds || []), blockId];
        await this.blocks.update(previousSibling.id, { childIds: updatedChildIds });

        // Update current block's parentId
        await this.blocks.update(blockId, {
            parentId: previousSibling.id,
            position: updatedChildIds.length - 1
        });

        return true;
    }

    /**
     * Outdent block (move to parent's level)
     */
    async outdentBlock(blockId) {
        const block = await this.blocks.get(blockId);
        if (!block || !block.parentId) return false;

        const parent = await this.blocks.get(block.parentId);
        if (!parent) return false;

        // Remove from current parent's childIds
        const updatedChildIds = parent.childIds.filter(id => id !== blockId);
        await this.blocks.update(parent.id, { childIds: updatedChildIds });

        // Move to grandparent level
        await this.blocks.update(blockId, {
            parentId: parent.parentId,
            position: parent.position + 1
        });

        return true;
    }

    /**
     * Reorder blocks
     */
    async reorderBlocks(pageId, parentId, blockIds) {
        const updates = blockIds.map((id, index) => ({
            key: id,
            changes: { position: index }
        }));

        await this.blocks.bulkUpdate(updates);
    }

    /**
     * Get page by ID
     */
    async getPage(pageId) {
        return await this.pages.get(pageId);
    }

    /**
     * Get all pages
     */
    async getAllPages() {
        return await this.pages.toArray();
    }

    /**
     * Update page
     */
    async updatePage(pageId, updates) {
        return await this.pages.update(pageId, {
            ...updates,
            updatedAt: Date.now()
        });
    }

    /**
     * Delete page and all its blocks
     */
    async deletePage(pageId) {
        // Delete all blocks
        await this.blocks.where('pageId').equals(pageId).delete();

        // Delete page
        await this.pages.delete(pageId);
        return true;
    }

    /**
     * Export page to JSON (for backup/migration)
     */
    async exportPage(pageId) {
        const page = await this.getPage(pageId);
        const blocks = await this.getAllPageBlocks(pageId);

        return {
            page,
            blocks
        };
    }

    /**
     * Import page from JSON
     */
    async importPage(data) {
        const { page, blocks } = data;

        // Create page
        delete page.id; // Let DB generate new ID
        const newPageId = await this.pages.add(page);

        // Create blocks with ID mapping
        const idMap = {};
        for (const block of blocks) {
            const oldId = block.id;
            delete block.id;
            block.pageId = newPageId;

            // Update parentId if it references an old ID
            if (block.parentId && idMap[block.parentId]) {
                block.parentId = idMap[block.parentId];
            }

            const newId = await this.blocks.add(block);
            idMap[oldId] = newId;
        }

        return newPageId;
    }

    /**
     * Convert markdown file to blocks
     */
    async markdownToBlocks(pageId, markdown) {
        const lines = markdown.split('\n');
        let position = 0;

        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed) continue; // Skip empty lines

            let type = 'text';
            let content = trimmed;

            // Detect block type
            if (trimmed.startsWith('# ')) {
                type = 'h1';
                content = trimmed.substring(2);
            } else if (trimmed.startsWith('## ')) {
                type = 'h2';
                content = trimmed.substring(3);
            } else if (trimmed.startsWith('### ')) {
                type = 'h3';
                content = trimmed.substring(4);
            } else if (trimmed.startsWith('- [ ] ') || trimmed.startsWith('- [x] ')) {
                type = 'todo';
                content = trimmed.substring(6);
            } else if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
                type = 'bullet';
                content = trimmed.substring(2);
            } else if (trimmed.match(/^\d+\. /)) {
                type = 'numbered';
                content = trimmed.replace(/^\d+\. /, '');
            } else if (trimmed.startsWith('> ')) {
                type = 'quote';
                content = trimmed.substring(2);
            } else if (trimmed.startsWith('```')) {
                type = 'code';
                content = trimmed.substring(3);
            }

            await this.createBlock(pageId, type, content, null, position++);
        }
    }

    /**
     * Convert blocks to markdown
     */
    async blocksToMarkdown(pageId) {
        const blocks = await this.getAllPageBlocks(pageId);
        let markdown = '';

        for (const block of blocks) {
            let line = '';

            switch (block.type) {
                case 'h1':
                    line = `# ${block.content}`;
                    break;
                case 'h2':
                    line = `## ${block.content}`;
                    break;
                case 'h3':
                    line = `### ${block.content}`;
                    break;
                case 'todo':
                    line = `- [ ] ${block.content}`;
                    break;
                case 'bullet':
                    line = `- ${block.content}`;
                    break;
                case 'numbered':
                    line = `1. ${block.content}`;
                    break;
                case 'quote':
                    line = `> ${block.content}`;
                    break;
                case 'code':
                    line = `\`\`\`${block.content}`;
                    break;
                default:
                    line = block.content;
            }

            markdown += line + '\n';
        }

        return markdown;
    }

    return BlocksDatabase;
}

// Create singleton instance and expose globally
// Deferred initialization to ensure Dexie is loaded
let dbInstance = null;
let BlocksDatabase = null;

function initDatabase() {
    if (!dbInstance) {
        if (typeof Dexie === 'undefined') {
            console.error('Dexie.js not loaded! Block editor will not work.');
            return null;
        }
        try {
            // Create the class if not already created
            if (!BlocksDatabase) {
                BlocksDatabase = createBlocksDatabase();
                if (!BlocksDatabase) {
                    return null;
                }
            }
            dbInstance = new BlocksDatabase();
            console.log('BlocksDatabase initialized successfully');
        } catch (error) {
            console.error('Failed to initialize BlocksDatabase:', error);
            return null;
        }
    }
    return dbInstance;
}

// Initialize on first access or immediately if Dexie is available
if (typeof Dexie !== 'undefined') {
    window.db = initDatabase();
} else {
    // Wait for Dexie to load
    console.warn('Dexie not yet loaded, deferring database initialization');
    Object.defineProperty(window, 'db', {
        get: function() {
            return initDatabase();
        },
        configurable: true
    });
}

window.db;


/**
 * Block Component - Notion-style editable block
 * Handles rendering, keyboard events, and block operations
 */

// Note: db is global, defined in blocks-db.js

class Block {
    constructor(blockData, pageId, onUpdate, onDelete, onCreateBelow, onFocusPrevious) {
        this.id = blockData.id;
        this.pageId = pageId;
        this.type = blockData.type || 'text';
        this.content = blockData.content || '';
        this.properties = blockData.properties || {};
        this.parentId = blockData.parentId;
        this.childIds = blockData.childIds || [];
        this.position = blockData.position || 0;

        // Callbacks
        this.onUpdate = onUpdate;
        this.onDelete = onDelete;
        this.onCreateBelow = onCreateBelow;
        this.onFocusPrevious = onFocusPrevious;

        // DOM element
        this.element = null;
        this.contentElement = null;

        // State
        this.isSlashMenuOpen = false;
        this.slashMenuElement = null;
    }

    /**
     * Render the block
     */
    render() {
        const container = document.createElement('div');
        container.className = 'block-container';
        container.dataset.blockId = this.id;
        container.dataset.blockType = this.type;

        // Block handle (drag icon)
        const handle = document.createElement('div');
        handle.className = 'block-handle';
        handle.innerHTML = '‚ãÆ‚ãÆ';
        handle.draggable = true;

        // Block content area
        const contentArea = document.createElement('div');
        contentArea.className = 'block-content-area';

        // Render based on type
        const content = this.renderContent();
        contentArea.appendChild(content);

        container.appendChild(handle);
        container.appendChild(contentArea);

        // Setup event listeners
        this.setupEventListeners(content);

        this.element = container;
        this.contentElement = content;

        return container;
    }

    /**
     * Render content based on block type
     */
    renderContent() {
        const element = document.createElement('div');
        element.className = `block-content block-type-${this.type}`;
        element.contentEditable = true;
        element.setAttribute('data-placeholder', this.getPlaceholder());

        // Add prefix for specific block types
        if (this.type !== 'text') {
            const prefix = document.createElement('span');
            prefix.className = 'block-prefix';
            prefix.contentEditable = false;
            prefix.textContent = this.getPrefix();
            element.appendChild(prefix);
        }

        // Add content
        const textNode = document.createTextNode(this.content);
        element.appendChild(textNode);

        return element;
    }

    /**
     * Get placeholder text for block type
     */
    getPlaceholder() {
        const placeholders = {
            text: "Type '/' for commands",
            h1: 'Heading 1',
            h2: 'Heading 2',
            h3: 'Heading 3',
            todo: 'To-do',
            bullet: 'List',
            numbered: 'Numbered list',
            quote: 'Quote',
            code: 'Code',
            toggle: 'Toggle list'
        };
        return placeholders[this.type] || "Type '/' for commands";
    }

    /**
     * Get prefix for block type
     */
    getPrefix() {
        const prefixes = {
            h1: '# ',
            h2: '## ',
            h3: '### ',
            todo: '‚òê ',
            bullet: '‚Ä¢ ',
            numbered: '1. ',
            quote: '‚ùù ',
            toggle: '‚ñ∂ '
        };
        return prefixes[this.type] || '';
    }

    /**
     * Setup event listeners
     */
    setupEventListeners(content) {
        // Input event for content updates
        content.addEventListener('input', (e) => this.handleInput(e));

        // Keydown for special keys
        content.addEventListener('keydown', (e) => this.handleKeyDown(e));

        // Paste event
        content.addEventListener('paste', (e) => this.handlePaste(e));

        // Focus/blur events
        content.addEventListener('focus', () => this.handleFocus());
        content.addEventListener('blur', () => this.handleBlur());
    }

    /**
     * Handle input event
     */
    handleInput(e) {
        const newContent = this.getTextContent();

        // Check for slash command
        if (newContent.startsWith('/') && !this.isSlashMenuOpen) {
            this.openSlashMenu();
        } else if (this.isSlashMenuOpen && !newContent.startsWith('/')) {
            this.closeSlashMenu();
        }

        // Update content
        this.content = newContent;
        this.saveContent();

        // Notify parent
        if (this.onUpdate) {
            this.onUpdate(this.id, { content: newContent });
        }
    }

    /**
     * Handle keydown events
     */
    handleKeyDown(e) {
        // Enter key - create new block below
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();

            if (this.isSlashMenuOpen) {
                this.closeSlashMenu();
            }

            // Get cursor position
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);
            const cursorOffset = range.startOffset;
            const textContent = this.getTextContent();

            // Split content at cursor
            const beforeCursor = textContent.substring(0, cursorOffset);
            const afterCursor = textContent.substring(cursorOffset);

            // Update current block
            this.content = beforeCursor;
            this.setTextContent(beforeCursor);
            this.saveContent();

            // Create new block with remaining text
            if (this.onCreateBelow) {
                this.onCreateBelow(this.id, afterCursor);
            }
        }

        // Backspace at start - delete block and merge with previous
        else if (e.key === 'Backspace') {
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);

            if (range.startOffset === 0 && range.endOffset === 0) {
                e.preventDefault();

                const content = this.getTextContent();

                // Delete this block
                if (this.onDelete) {
                    this.onDelete(this.id, content);
                }
            }
        }

        // Tab - indent block
        else if (e.key === 'Tab') {
            e.preventDefault();

            if (e.shiftKey) {
                // Shift+Tab - outdent
                this.outdent();
            } else {
                // Tab - indent
                this.indent();
            }
        }

        // Arrow Up - focus previous block
        else if (e.key === 'ArrowUp') {
            const selection = window.getSelection();
            const range = selection.getRangeAt(0);

            // Only if at start of block
            if (range.startOffset === 0) {
                e.preventDefault();
                if (this.onFocusPrevious) {
                    this.onFocusPrevious(this.id);
                }
            }
        }

        // Escape - close slash menu
        else if (e.key === 'Escape') {
            if (this.isSlashMenuOpen) {
                e.preventDefault();
                this.closeSlashMenu();
            }
        }
    }

    /**
     * Handle paste event
     */
    handlePaste(e) {
        e.preventDefault();

        // Get plain text from clipboard
        const text = e.clipboardData.getData('text/plain');

        // Insert at cursor
        const selection = window.getSelection();
        if (!selection.rangeCount) return;

        const range = selection.getRangeAt(0);
        range.deleteContents();
        range.insertNode(document.createTextNode(text));

        // Move cursor to end of inserted text
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);

        // Trigger input event
        this.contentElement.dispatchEvent(new Event('input'));
    }

    /**
     * Handle focus
     */
    handleFocus() {
        this.element.classList.add('block-focused');
    }

    /**
     * Handle blur
     */
    handleBlur() {
        this.element.classList.remove('block-focused');
        this.saveContent();

        // Close slash menu
        if (this.isSlashMenuOpen) {
            setTimeout(() => this.closeSlashMenu(), 200);
        }
    }

    /**
     * Get text content (without HTML)
     */
    getTextContent() {
        let text = this.contentElement.textContent;

        // Remove prefix if present
        const prefix = this.getPrefix();
        if (prefix && text.startsWith(prefix)) {
            text = text.substring(prefix.length);
        }

        return text;
    }

    /**
     * Set text content
     */
    setTextContent(text) {
        // Clear content
        while (this.contentElement.firstChild) {
            this.contentElement.removeChild(this.contentElement.firstChild);
        }

        // Add prefix if needed
        if (this.type !== 'text') {
            const prefix = document.createElement('span');
            prefix.className = 'block-prefix';
            prefix.contentEditable = false;
            prefix.textContent = this.getPrefix();
            this.contentElement.appendChild(prefix);
        }

        // Add text
        this.contentElement.appendChild(document.createTextNode(text));
    }

    /**
     * Save content to database
     */
    async saveContent() {
        await db.updateBlockContent(this.id, this.content);
    }

    /**
     * Indent block
     */
    async indent() {
        const success = await db.indentBlock(this.id);
        if (success && this.onUpdate) {
            this.onUpdate(this.id, { action: 'indent' });
        }
    }

    /**
     * Outdent block
     */
    async outdent() {
        const success = await db.outdentBlock(this.id);
        if (success && this.onUpdate) {
            this.onUpdate(this.id, { action: 'outdent' });
        }
    }

    /**
     * Change block type
     */
    async changeType(newType) {
        this.type = newType;
        await db.updateBlockType(this.id, newType);

        // Re-render
        const newContent = this.renderContent();
        this.contentElement.parentNode.replaceChild(newContent, this.contentElement);
        this.contentElement = newContent;
        this.setupEventListeners(newContent);

        // Focus
        this.focus();

        if (this.onUpdate) {
            this.onUpdate(this.id, { type: newType });
        }
    }

    /**
     * Focus this block
     */
    focus() {
        this.contentElement.focus();

        // Move cursor to end
        const range = document.createRange();
        const selection = window.getSelection();
        range.selectNodeContents(this.contentElement);
        range.collapse(false);
        selection.removeAllRanges();
        selection.addRange(range);
    }

    /**
     * Open slash command menu
     */
    openSlashMenu() {
        this.isSlashMenuOpen = true;

        const menu = document.createElement('div');
        menu.className = 'slash-menu';
        menu.innerHTML = `
            <div class="slash-menu-item" data-type="text">
                <span class="slash-menu-icon">üìù</span>
                <div>
                    <div class="slash-menu-title">Text</div>
                    <div class="slash-menu-desc">Plain text</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="h1">
                <span class="slash-menu-icon">H1</span>
                <div>
                    <div class="slash-menu-title">Heading 1</div>
                    <div class="slash-menu-desc">Large heading</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="h2">
                <span class="slash-menu-icon">H2</span>
                <div>
                    <div class="slash-menu-title">Heading 2</div>
                    <div class="slash-menu-desc">Medium heading</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="h3">
                <span class="slash-menu-icon">H3</span>
                <div>
                    <div class="slash-menu-title">Heading 3</div>
                    <div class="slash-menu-desc">Small heading</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="todo">
                <span class="slash-menu-icon">‚òê</span>
                <div>
                    <div class="slash-menu-title">To-do list</div>
                    <div class="slash-menu-desc">Track tasks</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="bullet">
                <span class="slash-menu-icon">‚Ä¢</span>
                <div>
                    <div class="slash-menu-title">Bulleted list</div>
                    <div class="slash-menu-desc">Simple bullet list</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="numbered">
                <span class="slash-menu-icon">1.</span>
                <div>
                    <div class="slash-menu-title">Numbered list</div>
                    <div class="slash-menu-desc">Ordered list</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="quote">
                <span class="slash-menu-icon">‚ùù</span>
                <div>
                    <div class="slash-menu-title">Quote</div>
                    <div class="slash-menu-desc">Quotation block</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="code">
                <span class="slash-menu-icon">{ }</span>
                <div>
                    <div class="slash-menu-title">Code</div>
                    <div class="slash-menu-desc">Code snippet</div>
                </div>
            </div>
            <div class="slash-menu-item" data-type="toggle">
                <span class="slash-menu-icon">‚ñ∂</span>
                <div>
                    <div class="slash-menu-title">Toggle list</div>
                    <div class="slash-menu-desc">Collapsible content</div>
                </div>
            </div>
        `;

        // Position menu
        const rect = this.contentElement.getBoundingClientRect();
        menu.style.position = 'fixed';
        menu.style.top = `${rect.bottom + 5}px`;
        menu.style.left = `${rect.left}px`;

        // Add click handlers
        menu.querySelectorAll('.slash-menu-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const type = item.dataset.type;

                // Remove slash from content
                const newContent = this.getTextContent().substring(1);
                this.content = newContent;
                this.setTextContent(newContent);

                // Change type
                this.changeType(type);

                this.closeSlashMenu();
            });
        });

        document.body.appendChild(menu);
        this.slashMenuElement = menu;
    }

    /**
     * Close slash command menu
     */
    closeSlashMenu() {
        if (this.slashMenuElement) {
            this.slashMenuElement.remove();
            this.slashMenuElement = null;
        }
        this.isSlashMenuOpen = false;
    }

    /**
     * Destroy block
     */
    destroy() {
        this.closeSlashMenu();
        if (this.element && this.element.parentNode) {
            this.element.parentNode.removeChild(this.element);
        }
    }
}

// Expose globally
window.Block = Block;


/**
 * Block Editor - Manages collection of blocks for a page
 * Main editor component for Notion-style block editing
 */

// Note: db and Block are global, defined in blocks-db.js and block.js

class BlockEditor {
    constructor(container) {
        this.container = container;
        this.pageId = null;
        this.blocks = new Map(); // blockId -> Block instance
        this.blockElements = new Map(); // blockId -> DOM element

        // Callbacks
        this.onPageUpdate = null;
        this.onBlockUpdate = null;
    }

    /**
     * Initialize editor with a page
     */
    async init(pageId) {
        this.pageId = pageId;

        // Clear existing
        this.clearBlocks();

        // Load page
        const page = await db.getPage(pageId);
        if (!page) {
            throw new Error('Page not found');
        }

        // Render editor UI
        this.render(page);

        // Load and render blocks
        await this.loadBlocks();
    }

    /**
     * Render editor UI
     */
    render(page) {
        this.container.innerHTML = '';
        this.container.className = 'block-editor';

        // Title
        const titleEl = document.createElement('div');
        titleEl.className = 'block-editor-title';
        titleEl.contentEditable = true;
        titleEl.textContent = page.title;
        titleEl.addEventListener('input', (e) => {
            this.updatePageTitle(e.target.textContent);
        });
        titleEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Focus first block
                const firstBlock = this.blocks.values().next().value;
                if (firstBlock) {
                    firstBlock.focus();
                }
            }
        });

        // Blocks container
        const blocksContainer = document.createElement('div');
        blocksContainer.className = 'block-editor-blocks';
        blocksContainer.id = 'blocksContainer';

        this.container.appendChild(titleEl);
        this.container.appendChild(blocksContainer);

        this.blocksContainer = blocksContainer;
    }

    /**
     * Load blocks from database
     */
    async loadBlocks() {
        const blocks = await db.getPageBlocks(this.pageId);

        if (blocks.length === 0) {
            // Create initial empty block
            await db.createBlock(this.pageId, 'text', '', null, 0);
            await this.loadBlocks();
            return;
        }

        // Render blocks
        for (const blockData of blocks) {
            await this.renderBlock(blockData);
        }
    }

    /**
     * Render a single block
     */
    async renderBlock(blockData, position = null) {
        const block = new Block(
            blockData,
            this.pageId,
            (blockId, updates) => this.handleBlockUpdate(blockId, updates),
            (blockId, content) => this.handleBlockDelete(blockId, content),
            (blockId, content) => this.handleCreateBlockBelow(blockId, content),
            (blockId) => this.handleFocusPrevious(blockId)
        );

        const element = block.render();

        // Add to container at position
        if (position !== null && position < this.blocksContainer.children.length) {
            this.blocksContainer.insertBefore(element, this.blocksContainer.children[position]);
        } else {
            this.blocksContainer.appendChild(element);
        }

        // Store references
        this.blocks.set(blockData.id, block);
        this.blockElements.set(blockData.id, element);

        return block;
    }

    /**
     * Handle block update
     */
    async handleBlockUpdate(blockId, updates) {
        if (updates.action === 'indent' || updates.action === 'outdent') {
            // Reload blocks to reflect hierarchy changes
            await this.reloadBlocks();
        }

        if (this.onBlockUpdate) {
            this.onBlockUpdate(blockId, updates);
        }
    }

    /**
     * Handle block delete
     */
    async handleBlockDelete(blockId, content) {
        // Find previous block
        const blocksArray = Array.from(this.blocks.values());
        const currentIndex = blocksArray.findIndex(b => b.id === blockId);

        if (currentIndex > 0) {
            const previousBlock = blocksArray[currentIndex - 1];

            // Append content to previous block
            if (content) {
                previousBlock.content += content;
                previousBlock.setTextContent(previousBlock.content);
                await previousBlock.saveContent();
            }

            // Focus previous block
            previousBlock.focus();
        }

        // Delete from database
        await db.deleteBlock(blockId);

        // Remove from UI
        const block = this.blocks.get(blockId);
        if (block) {
            block.destroy();
        }
        this.blocks.delete(blockId);
        this.blockElements.delete(blockId);
    }

    /**
     * Handle create block below
     */
    async handleCreateBlockBelow(blockId, content = '') {
        const currentBlock = this.blocks.get(blockId);
        if (!currentBlock) return;

        // Get position of current block
        const blocksArray = Array.from(this.blocks.values());
        const currentIndex = blocksArray.findIndex(b => b.id === blockId);
        const newPosition = currentIndex + 1;

        // Create new block in database
        const newBlockId = await db.createBlock(
            this.pageId,
            'text',
            content,
            currentBlock.parentId,
            newPosition
        );

        // Get new block data
        const newBlockData = await db.blocks.get(newBlockId);

        // Render new block
        const newBlock = await this.renderBlock(newBlockData, newPosition);

        // Focus new block
        newBlock.focus();

        // Update positions of blocks below
        await this.updateBlockPositions();
    }

    /**
     * Handle focus previous block
     */
    handleFocusPrevious(blockId) {
        const blocksArray = Array.from(this.blocks.values());
        const currentIndex = blocksArray.findIndex(b => b.id === blockId);

        if (currentIndex > 0) {
            const previousBlock = blocksArray[currentIndex - 1];
            previousBlock.focus();
        }
    }

    /**
     * Update block positions
     */
    async updateBlockPositions() {
        const blocksArray = Array.from(this.blocks.values());
        const updates = blocksArray.map((block, index) => ({
            key: block.id,
            changes: { position: index }
        }));

        if (updates.length > 0) {
            await db.blocks.bulkUpdate(updates);
        }
    }

    /**
     * Reload all blocks
     */
    async reloadBlocks() {
        this.clearBlocks();
        await this.loadBlocks();
    }

    /**
     * Clear all blocks
     */
    clearBlocks() {
        // Destroy all block instances
        this.blocks.forEach(block => block.destroy());
        this.blocks.clear();
        this.blockElements.clear();

        // Clear container
        if (this.blocksContainer) {
            this.blocksContainer.innerHTML = '';
        }
    }

    /**
     * Update page title
     */
    async updatePageTitle(title) {
        await db.updatePage(this.pageId, { title });

        if (this.onPageUpdate) {
            this.onPageUpdate({ title });
        }
    }

    /**
     * Export page to markdown
     */
    async exportToMarkdown() {
        return await db.blocksToMarkdown(this.pageId);
    }

    /**
     * Import from markdown
     */
    async importFromMarkdown(markdown) {
        // Clear existing blocks
        const existingBlocks = await db.getAllPageBlocks(this.pageId);
        for (const block of existingBlocks) {
            await db.deleteBlock(block.id);
        }

        // Convert markdown to blocks
        await db.markdownToBlocks(this.pageId, markdown);

        // Reload
        await this.reloadBlocks();
    }

    /**
     * Get page data
     */
    async getPageData() {
        return await db.exportPage(this.pageId);
    }

    /**
     * Destroy editor
     */
    destroy() {
        this.clearBlocks();
        this.container.innerHTML = '';
        this.pageId = null;
    }
}

// Expose globally
window.BlockEditor = BlockEditor;


/**
 * Editor Module - Handles editor with CodeMirror integration
 */
class Editor {
    constructor() {
        this.cm = null; // CodeMirror instance
        this.fallbackTextarea = null;
        this.onChange = null; // Callback when content changes
        this.useCodeMirror = true;
    }

    /**
     * Initialize editor
     */
    async init() {
        const container = document.getElementById('editor');
        if (!container) {
            console.error('Editor container not found');
            return false;
        }

        try {
            // Try to initialize CodeMirror
            if (this.useCodeMirror && window.CodeMirror) {
                await this.initCodeMirror(container);
            } else {
                this.initFallback(container);
            }

            return true;
        } catch (error) {
            console.warn('CodeMirror failed, using fallback:', error);
            this.initFallback(container);
            return true;
        }
    }

    /**
     * Initialize CodeMirror
     */
    async initCodeMirror(container) {
        this.cm = window.CodeMirror.fromTextArea(container, {
            mode: 'markdown',
            theme: 'default',
            lineNumbers: true,
            lineWrapping: true,
            autofocus: true,
            indentUnit: 4,
            tabSize: 4,
            indentWithTabs: false,
            extraKeys: {
                'Ctrl-S': () => { /* handled globally */ },
                'Cmd-S': () => { /* handled globally */ },
                'Ctrl-B': () => this.insertMarkdown('**', '**', 'bold'),
                'Cmd-B': () => this.insertMarkdown('**', '**', 'bold'),
                'Ctrl-I': () => this.insertMarkdown('*', '*', 'italic'),
                'Cmd-I': () => this.insertMarkdown('*', '*', 'italic'),
                'Ctrl-K': () => this.insertMarkdown('[', '](url)', 'link'),
                'Cmd-K': () => this.insertMarkdown('[', '](url)', 'link')
            },
            // Additional addons
            matchBrackets: true,
            autoCloseBrackets: true,
            styleActiveLine: true,
            highlightSelectionMatches: {
                showToken: /\w/,
                annotateScrollbar: true
            }
        });

        // Set change handler
        this.cm.on('change', () => {
            if (this.onChange) {
                this.onChange(this.getValue());
            }
        });

        console.log('CodeMirror initialized successfully');
    }

    /**
     * Initialize fallback textarea editor
     */
    initFallback(container) {
        this.fallbackTextarea = container;
        this.fallbackTextarea.style.display = 'block';

        this.fallbackTextarea.addEventListener('input', () => {
            if (this.onChange) {
                this.onChange(this.getValue());
            }
        });

        console.log('Using fallback textarea editor');
    }

    /**
     * Get editor content
     */
    getValue() {
        if (this.cm) {
            return this.cm.getValue();
        } else if (this.fallbackTextarea) {
            return this.fallbackTextarea.value;
        }
        return '';
    }

    /**
     * Set editor content
     */
    setValue(content) {
        if (this.cm) {
            this.cm.setValue(content || '');
        } else if (this.fallbackTextarea) {
            this.fallbackTextarea.value = content || '';
        }
    }

    /**
     * Insert markdown formatting
     */
    insertMarkdown(prefix, suffix, placeholder) {
        if (this.cm) {
            const doc = this.cm.getDoc();
            const cursor = doc.getCursor();
            const selection = doc.getSelection();

            if (selection) {
                doc.replaceSelection(prefix + selection + suffix);
            } else {
                const text = prefix + placeholder + suffix;
                doc.replaceRange(text, cursor);
                // Select the placeholder
                doc.setSelection(
                    { line: cursor.line, ch: cursor.ch + prefix.length },
                    { line: cursor.line, ch: cursor.ch + prefix.length + placeholder.length }
                );
            }

            this.cm.focus();
        } else if (this.fallbackTextarea) {
            const start = this.fallbackTextarea.selectionStart;
            const end = this.fallbackTextarea.selectionEnd;
            const text = this.fallbackTextarea.value;
            const selection = text.substring(start, end);

            let newText = selection ? (prefix + selection + suffix) : (prefix + placeholder + suffix);
            this.fallbackTextarea.value = text.substring(0, start) + newText + text.substring(end);

            if (selection) {
                this.fallbackTextarea.setSelectionRange(start + newText.length, start + newText.length);
            } else {
                this.fallbackTextarea.setSelectionRange(start + prefix.length, start + prefix.length + placeholder.length);
            }

            this.fallbackTextarea.focus();
        }

        if (this.onChange) {
            this.onChange(this.getValue());
        }
    }

    /**
     * Set theme
     */
    setTheme(theme) {
        if (this.cm) {
            // Map app themes to CodeMirror themes
            const cmThemes = {
                'dark': 'material-darker',
                'light': 'default',
                'dracula': 'dracula',
                'nord': 'nord',
                'monokai': 'monokai'
            };

            const cmTheme = cmThemes[theme] || 'default';
            this.cm.setOption('theme', cmTheme);
        }
    }

    /**
     * Set font size
     */
    setFontSize(size) {
        if (this.cm) {
            this.cm.getWrapperElement().style.fontSize = size;
            this.cm.refresh();
        } else if (this.fallbackTextarea) {
            this.fallbackTextarea.style.fontSize = size;
        }
    }

    /**
     * Set font family
     */
    setFontFamily(family) {
        if (this.cm) {
            this.cm.getWrapperElement().style.fontFamily = family;
            this.cm.refresh();
        } else if (this.fallbackTextarea) {
            this.fallbackTextarea.style.fontFamily = family;
        }
    }

    /**
     * Refresh editor
     */
    refresh() {
        if (this.cm) {
            this.cm.refresh();
        }
    }

    /**
     * Focus editor
     */
    focus() {
        if (this.cm) {
            this.cm.focus();
        } else if (this.fallbackTextarea) {
            this.fallbackTextarea.focus();
        }
    }

    /**
     * Get cursor position info
     */
    getCursorInfo() {
        if (this.cm) {
            const cursor = this.cm.getCursor();
            const line = cursor.line + 1;
            const ch = cursor.ch + 1;
            return { line, column: ch };
        }
        return { line: 0, column: 0 };
    }

    /**
     * Get text statistics
     */
    getStats() {
        const content = this.getValue();
        const lines = content.split('\n').length;
        const words = content.trim() ? content.trim().split(/\s+/).length : 0;
        const chars = content.length;

        return { lines, words, chars };
    }

    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        const panel = document.getElementById('editorPanel');
        if (panel) {
            panel.classList.toggle('fullscreen-mode');
            if (this.cm) {
                setTimeout(() => this.cm.refresh(), 100);
            }
        }
    }
}


/**
 * Preview Module - Handles markdown preview rendering
 */
class Preview {
    constructor() {
        this.container = null;
        this.isFullscreen = false;
    }

    /**
     * Initialize preview
     */
    init() {
        this.container = document.getElementById('preview');
        if (!this.container) {
            console.error('Preview container not found');
            return false;
        }

        // Initialize marked.js with extensions
        if (window.marked) {
            this.initMarked();
        }

        // Initialize mermaid
        if (window.mermaid) {
            window.mermaid.initialize({
                startOnLoad: false,
                theme: 'dark',
                securityLevel: 'loose'
            });
        }

        return true;
    }

    /**
     * Initialize marked with extensions
     */
    initMarked() {
        // Add GFM heading IDs
        if (window.markedGfmHeadingId) {
            marked.use(window.markedGfmHeadingId.gfmHeadingId());
        }

        // Add syntax highlighting
        if (window.markedHighlight && window.hljs) {
            marked.use(window.markedHighlight.markedHighlight({
                langPrefix: 'language-',
                highlight(code, lang) {
                    const language = window.hljs.getLanguage(lang) ? lang : 'plaintext';
                    return window.hljs.highlight(code, { language }).value;
                }
            }));
        }

        // Custom renderer for bidirectional editing
        this.setupBidirectionalRenderer();
    }

    /**
     * Setup custom renderer for line tracking
     */
    setupBidirectionalRenderer() {
        // This will be handled in parseWithLineNumbers method
    }

    /**
     * Update preview with markdown content
     */
    update(markdown) {
        if (!this.container || !window.marked) return;

        try {
            // Create line mapping
            this.createLineMapping(markdown);

            // Parse markdown with custom renderer
            let html = this.parseWithLineNumbers(markdown);

            // Process chart blocks
            html = this.processCharts(html);

            // Update container
            this.container.innerHTML = html;

            // Render mermaid diagrams
            if (window.mermaid) {
                window.mermaid.run({
                    nodes: this.container.querySelectorAll('.language-mermaid, .language-chart')
                });
            }

            // Render chart.js charts
            this.renderCharts();

            // Setup click handlers for bidirectional editing
            this.setupBidirectionalHandlers();

        } catch (error) {
            console.error('Preview render error:', error);
            this.container.innerHTML = `<p style="color: red;">Error rendering preview: ${error.message}</p>`;
        }
    }

    /**
     * Create line mapping from markdown
     */
    createLineMapping(markdown) {
        const lines = markdown.split('\n');
        this.lineMapping = {};

        lines.forEach((line, index) => {
            const trimmed = line.trim();
            if (trimmed) {
                // Store line number for non-empty lines
                this.lineMapping[trimmed.substring(0, 50)] = index;
            }
        });
    }

    /**
     * Parse markdown with line number tracking
     */
    parseWithLineNumbers(markdown) {
        const lines = markdown.split('\n');
        let html = marked.parse(markdown);

        // Post-process HTML to add line numbers and editable class
        // Find text content in HTML and match it back to source lines
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;

        const elements = tempDiv.querySelectorAll('h1, h2, h3, h4, h5, h6, p, li, blockquote');

        elements.forEach(element => {
            const text = element.textContent.trim();
            if (text) {
                // Find the line number in the source
                const lineNumber = this.findLineNumber(text, lines);
                if (lineNumber !== -1) {
                    element.setAttribute('data-source-line', lineNumber);
                    element.classList.add('editable-element');
                }
            }
        });

        return tempDiv.innerHTML;
    }

    /**
     * Find line number for given text in source
     */
    findLineNumber(text, lines) {
        // Try exact match first
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim() === text || lines[i].includes(text.substring(0, 30))) {
                return i;
            }
        }

        // Try fuzzy match (removing markdown syntax)
        const cleanText = text.replace(/[*_`#]/g, '').trim();
        for (let i = 0; i < lines.length; i++) {
            const cleanLine = lines[i].replace(/[*_`#]/g, '').trim();
            if (cleanLine.includes(cleanText.substring(0, 30))) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Setup bidirectional click handlers
     */
    setupBidirectionalHandlers() {
        if (!this.container) return;

        const editableElements = this.container.querySelectorAll('.editable-element');

        editableElements.forEach(element => {
            element.style.cursor = 'pointer';
            element.title = 'Click to jump to editor';

            element.addEventListener('click', (e) => {
                const sourceLine = element.getAttribute('data-source-line');
                if (sourceLine !== null && this.onElementClick) {
                    e.stopPropagation();
                    this.onElementClick(parseInt(sourceLine));
                }
            });
        });
    }

    /**
     * Process chart code blocks
     */
    processCharts(html) {
        // This will be enhanced by the charts extension
        return html;
    }

    /**
     * Render Chart.js charts
     */
    renderCharts() {
        if (!window.Chart) return;

        const chartBlocks = this.container.querySelectorAll('pre code.language-chart');
        chartBlocks.forEach((block, index) => {
            try {
                const config = JSON.parse(block.textContent);
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${index}`;
                canvas.width = 400;
                canvas.height = 300;

                // Replace code block with canvas
                const pre = block.parentElement;
                pre.parentElement.replaceChild(canvas, pre);

                // Create chart
                new Chart(canvas, config);
            } catch (e) {
                console.error('Chart render error:', e);
            }
        });
    }

    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        const panel = document.getElementById('previewPanel');
        if (panel) {
            panel.classList.toggle('fullscreen-mode');
            this.isFullscreen = !this.isFullscreen;

            // Update button icon if needed
            const icon = document.querySelector('#previewPanel .panel-header .icon-btn use');
            if (icon) {
                icon.setAttribute('href', this.isFullscreen ? '#icon-minimize' : '#icon-maximize');
            }
        }
    }

    /**
     * Clear preview
     */
    clear() {
        if (this.container) {
            this.container.innerHTML = '';
        }
    }

    /**
     * Get preview HTML
     */
    getHTML() {
        return this.container ? this.container.innerHTML : '';
    }

    /**
     * Export preview to standalone HTML
     */
    exportHTML(markdown, theme) {
        const html = marked.parse(markdown);
        const themeColors = this.getThemeColors(theme);

        return `<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exported Document</title>
    <style>
        body {
            font-family: 'Consolas', monospace;
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: ${themeColors.bg};
            color: ${themeColors.text};
            line-height: 1.6;
        }
        h1, h2 { color: ${themeColors.accent}; border-bottom: 1px solid ${themeColors.border}; }
        code { background: ${themeColors.codeBg}; padding: 2px 5px; border-radius: 3px; }
        pre { background: ${themeColors.codeBg}; padding: 15px; border-radius: 5px; overflow-x: auto; }
        blockquote { border-left: 4px solid ${themeColors.border}; padding-left: 1em; color: ${themeColors.mutedText}; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid ${themeColors.border}; padding: 8px 12px; }
        th { background: ${themeColors.codeBg}; font-weight: bold; }
    </style>
</head>
<body>
${html}
</body>
</html>`;
    }

    /**
     * Get theme colors for export
     */
    getThemeColors(theme) {
        const themes = {
            dark: { bg: '#1e1e1e', text: '#d4d4d4', accent: '#007acc', border: '#3e3e42', codeBg: '#2d2d30', mutedText: '#808080' },
            light: { bg: '#fff', text: '#000', accent: '#0066cc', border: '#ccc', codeBg: '#f0f0f0', mutedText: '#666' }
        };

        return themes[theme] || themes.dark;
    }
}


/**
 * Mindmap Module - Handles mindmap visualization
 */
class Mindmap {
    constructor() {
        this.container = null;
        this.instance = null;
        this.isFullscreen = false;
        this.focusEnabled = true;
        this.currentFocusNode = null;
        this.nodes = [];
    }

    /**
     * Initialize mindmap
     */
    async init() {
        this.container = document.getElementById('mindmap');
        if (!this.container) {
            console.error('Mindmap container not found');
            return false;
        }

        // Wait for markmap to load
        try {
            await this.waitForMarkmap();
            console.log('Markmap ready');
            return true;
        } catch (error) {
            console.error('Markmap initialization failed:', error);
            this.container.innerHTML = '<div style="text-align:center;padding:50px;color:var(--text-secondary)">Markmap failed to load</div>';
            return false;
        }
    }

    /**
     * Wait for markmap library to load
     */
    waitForMarkmap() {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const check = setInterval(() => {
                if (window.markmap && window.markmap.Markmap) {
                    clearInterval(check);
                    resolve();
                }
                if (Date.now() - start > 10000) {
                    clearInterval(check);
                    reject(new Error('Markmap load timeout'));
                }
            }, 100);
        });
    }

    /**
     * Render mindmap from markdown
     */
    render(markdown) {
        if (!window.markmap || !this.container) return;

        try {
            // Destroy previous instance
            if (this.instance) {
                this.instance.destroy();
            }

            // Transform markdown to mindmap data
            const transformer = new window.markmap.Transformer();
            const { root } = transformer.transform(markdown || '# Empty');

            // Clear container
            this.container.innerHTML = '';

            // Create SVG
            const svg = window.d3.select('#mindmap')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%');

            // Create and render mindmap
            this.instance = window.markmap.Markmap.create(svg.node(), null, root);
            this.instance.fit();

            // Store nodes for focus management
            this.extractNodes(root);

            // Apply focus if enabled
            if (this.focusEnabled && this.currentFocusNode !== null) {
                this.highlightNode(this.currentFocusNode);
            }

        } catch (error) {
            console.error('Mindmap render error:', error);
            this.container.innerHTML = `<div style="text-align:center;padding:50px;color:var(--text-secondary)">Error: ${error.message}</div>`;
        }
    }

    /**
     * Extract all nodes from mindmap tree for indexing
     */
    extractNodes(node, depth = 0, index = [0]) {
        if (!node) return;

        this.nodes = this.nodes || [];
        node.nodeIndex = index[0]++;
        this.nodes.push({
            index: node.nodeIndex,
            depth: depth,
            content: node.content,
            node: node
        });

        if (node.children && node.children.length > 0) {
            node.children.forEach(child => {
                this.extractNodes(child, depth + 1, index);
            });
        }
    }

    /**
     * Highlight a specific node by index
     */
    highlightNode(nodeIndex) {
        if (!this.instance || !this.focusEnabled) return;

        this.currentFocusNode = nodeIndex;

        // Remove previous highlights
        const svg = this.container.querySelector('svg');
        if (!svg) return;

        // Remove all existing highlights
        svg.querySelectorAll('.mindmap-active-node').forEach(el => {
            el.classList.remove('mindmap-active-node');
        });

        // Find and highlight the target node
        const circles = svg.querySelectorAll('circle');
        if (circles[nodeIndex]) {
            circles[nodeIndex].classList.add('mindmap-active-node');

            // Scroll to node if needed
            const node = circles[nodeIndex];
            const bbox = node.getBBox();
            const ctm = node.getCTM();

            if (ctm) {
                const x = bbox.x + ctm.e;
                const y = bbox.y + ctm.f;

                // Center the node in view (using markmap's pan/zoom)
                if (this.instance.svg) {
                    // Markmap uses d3 zoom, we can access it
                    const zoom = window.d3.zoom();
                    const svg = window.d3.select(this.container.querySelector('svg'));

                    // Calculate transform to center node
                    const width = this.container.clientWidth;
                    const height = this.container.clientHeight;
                    const scale = 1;
                    const translateX = width / 2 - x * scale;
                    const translateY = height / 2 - y * scale;

                    // Apply transform smoothly
                    svg.transition()
                        .duration(500)
                        .call(zoom.transform, window.d3.zoomIdentity.translate(translateX, translateY).scale(scale));
                }
            }
        }
    }

    /**
     * Toggle focus feature
     */
    toggleFocus() {
        this.focusEnabled = !this.focusEnabled;

        if (!this.focusEnabled) {
            // Remove all highlights
            const svg = this.container?.querySelector('svg');
            if (svg) {
                svg.querySelectorAll('.mindmap-active-node').forEach(el => {
                    el.classList.remove('mindmap-active-node');
                });
            }
        } else if (this.currentFocusNode !== null) {
            // Restore highlight
            this.highlightNode(this.currentFocusNode);
        }

        return this.focusEnabled;
    }

    /**
     * Set focus on specific heading by text
     */
    focusOnHeading(headingText) {
        if (!this.focusEnabled) return;

        const nodeInfo = this.nodes.find(n =>
            n.content && n.content.toLowerCase().includes(headingText.toLowerCase())
        );

        if (nodeInfo) {
            this.highlightNode(nodeInfo.index);
        }
    }

    /**
     * Fit mindmap to container
     */
    fit() {
        if (this.instance) {
            this.instance.fit();
        }
    }

    /**
     * Toggle fullscreen mode
     */
    toggleFullscreen() {
        const panel = document.getElementById('mindmapPanel');
        if (panel) {
            panel.classList.toggle('fullscreen-mode');
            this.isFullscreen = !this.isFullscreen;

            // Refresh mindmap after fullscreen toggle
            setTimeout(() => this.fit(), 100);
        }
    }

    /**
     * Clear mindmap
     */
    clear() {
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
        if (this.container) {
            this.container.innerHTML = '';
        }
    }

    /**
     * Export mindmap to SVG
     */
    exportSVG() {
        if (!this.container) return null;

        const svg = this.container.querySelector('svg');
        if (!svg) return null;

        const serializer = new XMLSerializer();
        return serializer.serializeToString(svg);
    }

    /**
     * Export mindmap to PNG (via canvas)
     */
    async exportPNG() {
        const svg = this.container.querySelector('svg');
        if (!svg || !window.html2canvas) return null;

        try {
            const canvas = await html2canvas(svg);
            return canvas.toDataURL('image/png');
        } catch (error) {
            console.error('Mindmap PNG export error:', error);
            return null;
        }
    }
}


/**
 * Presentation Module - Handles Reveal.js presentations
 */
class Presentation {
    constructor() {
        this.reveal = null;
        this.isActive = false;
        this.container = null;
    }

    /**
     * Initialize presentation container
     */
    init() {
        this.container = document.getElementById('preview');
        return true;
    }

    /**
     * Start presentation mode
     */
    async start(markdown) {
        if (!markdown.includes('---')) {
            alert('Use --- to separate slides');
            return false;
        }

        try {
            // Extract frontmatter if present
            let content = markdown;
            if (markdown.startsWith('---')) {
                const parts = markdown.split('---');
                if (parts.length >= 3) {
                    content = parts.slice(2).join('---').trim();
                }
            }

            // Create Reveal.js container
            this.container.innerHTML = `
                <div class="reveal">
                    <div class="slides">
                        <section data-markdown data-separator="^---$" data-separator-vertical="^--$">
                            <textarea data-template>${content}</textarea>
                        </section>
                    </div>
                </div>
            `;

            // Initialize Reveal.js
            const config = {
                embedded: true,
                hash: false,
                plugins: [window.RevealMarkdown],
                width: 960,
                height: 700,
                margin: 0.04,
                minScale: 0.2,
                maxScale: 2.0,
                // Auto-fit content
                center: true,
                transition: 'slide',
                backgroundTransition: 'fade'
            };

            this.reveal = new window.Reveal(document.querySelector('.reveal'), config);
            await this.reveal.initialize();

            this.isActive = true;
            return true;

        } catch (error) {
            console.error('Presentation start error:', error);
            return false;
        }
    }

    /**
     * Stop presentation mode
     */
    stop() {
        if (this.reveal) {
            this.reveal.destroy();
            this.reveal = null;
        }
        this.isActive = false;
        this.container.innerHTML = '';
    }

    /**
     * Toggle presentation mode
     */
    async toggle(markdown) {
        if (this.isActive) {
            this.stop();
            return false;
        } else {
            return await this.start(markdown);
        }
    }

    /**
     * Navigate to slide
     */
    slideTo(h, v = 0) {
        if (this.reveal) {
            this.reveal.slide(h, v);
        }
    }

    /**
     * Get total slides
     */
    getTotalSlides() {
        return this.reveal ? this.reveal.getTotalSlides() : 0;
    }

    /**
     * Get current slide index
     */
    getCurrentSlide() {
        if (!this.reveal) return { h: 0, v: 0 };
        const indices = this.reveal.getIndices();
        return indices;
    }

    /**
     * Export to PDF slides
     */
    async exportPDF(filename = 'slides.pdf') {
        if (!this.reveal || !window.jspdf) {
            console.error('Reveal or jsPDF not available');
            return false;
        }

        try {
            const { jsPDF } = window.jspdf;
            const totalSlides = this.getTotalSlides();
            const config = this.reveal.getConfig();
            const pdf = new jsPDF('l', 'px', [config.width, config.height]);
            const slidesContainer = document.querySelector('.reveal .slides');

            for (let i = 0; i < totalSlides; i++) {
                await this.reveal.slide(i, 0, 0);
                await new Promise(r => setTimeout(r, 500));

                const canvas = await window.html2canvas(slidesContainer, {
                    width: config.width,
                    height: config.height,
                    x: 0,
                    y: 0,
                    scale: 2 // Higher quality
                });

                if (i > 0) {
                    pdf.addPage([config.width, config.height], 'l');
                }

                pdf.addImage(
                    canvas.toDataURL('image/png'),
                    'PNG',
                    0, 0,
                    config.width,
                    config.height
                );
            }

            pdf.save(filename);
            return true;

        } catch (error) {
            console.error('PDF export error:', error);
            return false;
        }
    }

    /**
     * Export to PowerPoint (via PptxGenJS)
     */
    async exportPPTX(filename = 'presentation.pptx') {
        if (!this.reveal || !window.PptxGenJS) {
            console.error('Reveal or PptxGenJS not available');
            return false;
        }

        try {
            const pptx = new window.PptxGenJS();
            const totalSlides = this.getTotalSlides();
            const config = this.reveal.getConfig();

            for (let i = 0; i < totalSlides; i++) {
                await this.reveal.slide(i, 0, 0);
                await new Promise(r => setTimeout(r, 500));

                const slidesContainer = document.querySelector('.reveal .slides section.present');

                // Convert slide to image
                const canvas = await window.html2canvas(slidesContainer, {
                    scale: 2
                });

                const imgData = canvas.toDataURL('image/png');

                // Add slide to PPTX
                const slide = pptx.addSlide();
                slide.addImage({
                    data: imgData,
                    x: 0,
                    y: 0,
                    w: '100%',
                    h: '100%'
                });
            }

            await pptx.writeFile({ fileName: filename });
            return true;

        } catch (error) {
            console.error('PPTX export error:', error);
            return false;
        }
    }

    /**
     * Set theme
     */
    setTheme(theme) {
        const themeLink = document.getElementById('revealTheme');
        if (themeLink) {
            themeLink.href = `https://cdn.jsdelivr.net/npm/reveal.js@4.6.1/dist/theme/${theme}.css`;
        }
    }

    /**
     * Toggle fullscreen
     */
    toggleFullscreen() {
        const panel = document.getElementById('previewPanel');
        if (panel) {
            panel.classList.toggle('fullscreen-mode');

            if (this.reveal) {
                setTimeout(() => this.reveal.layout(), 100);
            }
        }
    }
}


/**
 * Presentation Templates Module
 * JSON-based customizable templates for professional presentations
 */
class PresentationTemplates {
    constructor() {
        this.templates = this.getDefaultTemplates();
        this.customTemplates = this.loadCustomTemplates();
    }

    /**
     * Get default professional templates
     */
    getDefaultTemplates() {
        return {
            corporate: {
                name: "Corporate Professional",
                description: "Professional corporate presentation",
                config: {
                    theme: "white",
                    transition: "slide",
                    backgroundTransition: "fade"
                },
                styling: {
                    primaryColor: "#003366",
                    secondaryColor: "#0066CC",
                    accentColor: "#FF6600",
                    backgroundColor: "#FFFFFF",
                    textColor: "#333333",
                    headingFont: "'Montserrat', sans-serif",
                    bodyFont: "'Open Sans', sans-serif",
                    fontSize: "28px",
                    headingFontSize: "48px"
                },
                logo: {
                    enabled: true,
                    position: "top-right",
                    url: "",
                    width: "80px",
                    height: "80px"
                },
                footer: {
                    enabled: true,
                    text: "¬© 2024 Company Name",
                    position: "bottom-right",
                    fontSize: "14px"
                },
                slideLayouts: {
                    title: {
                        background: "linear-gradient(135deg, #003366 0%, #0066CC 100%)",
                        textColor: "#FFFFFF",
                        align: "center"
                    },
                    content: {
                        background: "#FFFFFF",
                        textColor: "#333333",
                        align: "left"
                    },
                    twoColumn: {
                        background: "#FFFFFF",
                        columnGap: "40px"
                    },
                    quote: {
                        background: "#F5F5F5",
                        borderLeft: "5px solid #0066CC"
                    }
                }
            },
            modern: {
                name: "Modern Minimalist",
                description: "Clean and modern design",
                config: {
                    theme: "black",
                    transition: "convex",
                    backgroundTransition: "zoom"
                },
                styling: {
                    primaryColor: "#000000",
                    secondaryColor: "#FFFFFF",
                    accentColor: "#00D9FF",
                    backgroundColor: "#1A1A1A",
                    textColor: "#FFFFFF",
                    headingFont: "'Raleway', sans-serif",
                    bodyFont: "'Lato', sans-serif",
                    fontSize: "26px",
                    headingFontSize: "52px"
                },
                logo: {
                    enabled: false
                },
                footer: {
                    enabled: false
                },
                slideLayouts: {
                    title: {
                        background: "#000000",
                        textColor: "#FFFFFF",
                        align: "center"
                    },
                    content: {
                        background: "#1A1A1A",
                        textColor: "#FFFFFF",
                        align: "left"
                    }
                }
            },
            academic: {
                name: "Academic",
                description: "Classic academic presentation",
                config: {
                    theme: "serif",
                    transition: "fade",
                    backgroundTransition: "none"
                },
                styling: {
                    primaryColor: "#8B0000",
                    secondaryColor: "#2F4F4F",
                    accentColor: "#DAA520",
                    backgroundColor: "#FFFFF0",
                    textColor: "#2F4F4F",
                    headingFont: "'Merriweather', serif",
                    bodyFont: "'Crimson Text', serif",
                    fontSize: "24px",
                    headingFontSize: "44px"
                },
                logo: {
                    enabled: true,
                    position: "top-left",
                    url: "",
                    width: "100px",
                    height: "100px"
                },
                footer: {
                    enabled: true,
                    text: "University Name - Department",
                    position: "bottom-center",
                    fontSize: "16px"
                },
                slideLayouts: {
                    title: {
                        background: "#8B0000",
                        textColor: "#FFFFF0",
                        align: "center"
                    },
                    content: {
                        background: "#FFFFF0",
                        textColor: "#2F4F4F",
                        align: "left"
                    }
                }
            },
            startup: {
                name: "Startup Pitch",
                description: "Dynamic startup pitch deck",
                config: {
                    theme: "night",
                    transition: "zoom",
                    backgroundTransition: "slide"
                },
                styling: {
                    primaryColor: "#7C3AED",
                    secondaryColor: "#EC4899",
                    accentColor: "#F59E0B",
                    backgroundColor: "#0F172A",
                    textColor: "#F1F5F9",
                    headingFont: "'Poppins', sans-serif",
                    bodyFont: "'Inter', sans-serif",
                    fontSize: "28px",
                    headingFontSize: "56px"
                },
                logo: {
                    enabled: true,
                    position: "top-left",
                    url: "",
                    width: "120px",
                    height: "40px"
                },
                footer: {
                    enabled: true,
                    text: "Confidential",
                    position: "bottom-right",
                    fontSize: "12px"
                },
                slideLayouts: {
                    title: {
                        background: "linear-gradient(135deg, #7C3AED 0%, #EC4899 100%)",
                        textColor: "#FFFFFF",
                        align: "center"
                    },
                    content: {
                        background: "#0F172A",
                        textColor: "#F1F5F9",
                        align: "left"
                    },
                    metrics: {
                        background: "#1E293B",
                        gridColumns: "3",
                        cardBackground: "#334155"
                    }
                }
            }
        };
    }

    /**
     * Load custom templates from localStorage
     */
    loadCustomTemplates() {
        try {
            const saved = localStorage.getItem('mdnotes_presentation_templates');
            return saved ? JSON.parse(saved) : {};
        } catch (e) {
            console.error('Failed to load custom templates:', e);
            return {};
        }
    }

    /**
     * Save custom template
     */
    saveCustomTemplate(name, template) {
        this.customTemplates[name] = template;
        localStorage.setItem('mdnotes_presentation_templates', JSON.stringify(this.customTemplates));
    }

    /**
     * Get template by name
     */
    getTemplate(name) {
        return this.templates[name] || this.customTemplates[name] || this.templates.corporate;
    }

    /**
     * Get all templates
     */
    getAllTemplates() {
        return { ...this.templates, ...this.customTemplates };
    }

    /**
     * Apply template to presentation
     */
    applyTemplate(templateName, revealInstance) {
        const template = this.getTemplate(templateName);
        if (!template) return;

        // Apply Reveal.js config
        if (revealInstance && template.config) {
            revealInstance.configure(template.config);
        }

        // Apply custom CSS
        this.injectTemplateStyles(template);

        // Apply logo if enabled
        if (template.logo && template.logo.enabled && template.logo.url) {
            this.injectLogo(template.logo);
        }

        // Apply footer if enabled
        if (template.footer && template.footer.enabled) {
            this.injectFooter(template.footer);
        }
    }

    /**
     * Inject template styles
     */
    injectTemplateStyles(template) {
        const { styling } = template;
        if (!styling) return;

        // Remove existing template styles
        const existingStyle = document.getElementById('presentation-template-styles');
        if (existingStyle) {
            existingStyle.remove();
        }

        // Create new style element
        const styleEl = document.createElement('style');
        styleEl.id = 'presentation-template-styles';
        styleEl.textContent = `
            .reveal {
                font-family: ${styling.bodyFont};
                font-size: ${styling.fontSize};
                color: ${styling.textColor};
            }

            .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
                font-family: ${styling.headingFont};
                color: ${styling.primaryColor};
            }

            .reveal h1 {
                font-size: ${styling.headingFontSize};
            }

            .reveal .slides {
                background-color: ${styling.backgroundColor};
            }

            .reveal a {
                color: ${styling.accentColor};
            }

            .reveal .slide-background {
                background-color: ${styling.backgroundColor};
            }

            /* Title slide */
            .reveal .title-slide {
                background: ${template.slideLayouts?.title?.background || styling.backgroundColor};
                color: ${template.slideLayouts?.title?.textColor || styling.textColor};
                text-align: ${template.slideLayouts?.title?.align || 'center'};
            }

            /* Content slides */
            .reveal .content-slide {
                background: ${template.slideLayouts?.content?.background || styling.backgroundColor};
                color: ${template.slideLayouts?.content?.textColor || styling.textColor};
                text-align: ${template.slideLayouts?.content?.align || 'left'};
            }

            /* Code blocks */
            .reveal pre code {
                background: ${styling.primaryColor};
                color: ${styling.backgroundColor};
                padding: 20px;
                border-radius: 8px;
            }

            /* Lists */
            .reveal ul, .reveal ol {
                color: ${styling.textColor};
            }

            .reveal li {
                margin: 10px 0;
            }

            /* Tables */
            .reveal table {
                border-collapse: collapse;
                width: 100%;
            }

            .reveal th {
                background: ${styling.primaryColor};
                color: ${styling.backgroundColor};
                padding: 15px;
            }

            .reveal td {
                border: 1px solid ${styling.secondaryColor};
                padding: 12px;
            }

            /* Blockquotes */
            .reveal blockquote {
                border-left: 5px solid ${styling.accentColor};
                padding-left: 20px;
                font-style: italic;
            }
        `;

        document.head.appendChild(styleEl);
    }

    /**
     * Inject logo into presentation
     */
    injectLogo(logoConfig) {
        // Remove existing logo
        const existingLogo = document.getElementById('presentation-logo');
        if (existingLogo) {
            existingLogo.remove();
        }

        const logoEl = document.createElement('div');
        logoEl.id = 'presentation-logo';
        logoEl.style.position = 'fixed';
        logoEl.style.zIndex = '100';
        logoEl.style.width = logoConfig.width;
        logoEl.style.height = logoConfig.height;

        // Position
        const positions = {
            'top-left': { top: '20px', left: '20px' },
            'top-right': { top: '20px', right: '20px' },
            'bottom-left': { bottom: '20px', left: '20px' },
            'bottom-right': { bottom: '20px', right: '20px' }
        };

        const pos = positions[logoConfig.position] || positions['top-right'];
        Object.assign(logoEl.style, pos);

        logoEl.innerHTML = `<img src="${logoConfig.url}" style="width:100%;height:100%;object-fit:contain;" alt="Logo">`;

        document.querySelector('.reveal').appendChild(logoEl);
    }

    /**
     * Inject footer into presentation
     */
    injectFooter(footerConfig) {
        // Remove existing footer
        const existingFooter = document.getElementById('presentation-footer');
        if (existingFooter) {
            existingFooter.remove();
        }

        const footerEl = document.createElement('div');
        footerEl.id = 'presentation-footer';
        footerEl.style.position = 'fixed';
        footerEl.style.zIndex = '100';
        footerEl.style.fontSize = footerConfig.fontSize;
        footerEl.style.color = '#999';

        // Position
        const positions = {
            'bottom-left': { bottom: '10px', left: '20px' },
            'bottom-center': { bottom: '10px', left: '50%', transform: 'translateX(-50%)' },
            'bottom-right': { bottom: '10px', right: '20px' }
        };

        const pos = positions[footerConfig.position] || positions['bottom-right'];
        Object.assign(footerEl.style, pos);

        footerEl.textContent = footerConfig.text;

        document.querySelector('.reveal').appendChild(footerEl);
    }

    /**
     * Generate CSS from template
     */
    generateCSS(template) {
        // Returns CSS string for export
        return `/* Template: ${template.name} */`;
    }

    /**
     * Export template as JSON
     */
    exportTemplate(templateName) {
        const template = this.getTemplate(templateName);
        const json = JSON.stringify(template, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `${templateName}-template.json`;
        link.click();
        URL.revokeObjectURL(url);
    }

    /**
     * Import template from JSON
     */
    importTemplate(jsonString, name) {
        try {
            const template = JSON.parse(jsonString);
            this.saveCustomTemplate(name, template);
            return true;
        } catch (e) {
            console.error('Failed to import template:', e);
            return false;
        }
    }
}


/**
 * Export Module - Handles file exports
 */
class ExportManager {
    constructor(preview, presentation) {
        this.preview = preview;
        this.presentation = presentation;
    }

    /**
     * Export file in specified format
     */
    async export(format, content, filename = 'document') {
        switch (format) {
            case 'md':
                return this.exportMarkdown(content, filename);
            case 'html':
                return this.exportHTML(content, filename);
            case 'pdf-preview':
                return await this.exportPDFPreview(filename);
            case 'pdf-slides':
                return await this.exportPDFSlides(filename);
            case 'pptx':
                return await this.exportPPTX(filename);
            default:
                console.error('Unknown export format:', format);
                return false;
        }
    }

    /**
     * Export as Markdown
     */
    exportMarkdown(content, filename) {
        this.download(content, `${filename}.md`, 'text/markdown');
        return true;
    }

    /**
     * Export as HTML
     */
    exportHTML(content, filename) {
        const html = this.preview.exportHTML(content, 'dark');
        this.download(html, `${filename}.html`, 'text/html');
        return true;
    }

    /**
     * Export preview as PDF
     */
    async exportPDFPreview(filename) {
        if (!window.html2canvas || !window.jspdf) {
            alert('PDF export libraries not loaded');
            return false;
        }

        try {
            const { jsPDF } = window.jspdf;
            const previewEl = document.getElementById('preview');

            // Create canvas from preview
            const canvas = await window.html2canvas(previewEl, {
                scale: 2,
                useCORS: true,
                logging: false
            });

            const imgData = canvas.toDataURL('image/png');
            const imgWidth = 210; // A4 width in mm
            const imgHeight = (canvas.height * imgWidth) / canvas.width;

            const pdf = new jsPDF('p', 'mm', 'a4');
            let heightLeft = imgHeight;
            let position = 0;

            // Add first page
            pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
            heightLeft -= 297; // A4 height in mm

            // Add additional pages if needed
            while (heightLeft > 0) {
                position = heightLeft - imgHeight;
                pdf.addPage();
                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= 297;
            }

            pdf.save(`${filename}_preview.pdf`);
            return true;

        } catch (error) {
            console.error('PDF preview export error:', error);
            alert('Failed to export PDF preview');
            return false;
        }
    }

    /**
     * Export presentation as PDF slides
     */
    async exportPDFSlides(filename) {
        if (!this.presentation.isActive) {
            alert('Please enter presentation mode first');
            return false;
        }

        return await this.presentation.exportPDF(`${filename}_slides.pdf`);
    }

    /**
     * Export presentation as PowerPoint
     */
    async exportPPTX(filename) {
        if (!this.presentation.isActive) {
            // Start presentation silently
            const editor = window.app?.editor;
            if (editor) {
                const content = editor.getValue();
                await this.presentation.start(content);
            }
        }

        const result = await this.presentation.exportPPTX(`${filename}.pptx`);

        // Stop presentation if we started it
        if (this.presentation.isActive) {
            this.presentation.stop();
        }

        return result;
    }

    /**
     * Download helper
     */
    download(content, filename, mimeType) {
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }

    /**
     * Show export menu
     */
    showMenu() {
        const menu = document.getElementById('exportMenu');
        if (menu) {
            menu.classList.toggle('show');
        }
    }

    /**
     * Hide export menu
     */
    hideMenu() {
        const menu = document.getElementById('exportMenu');
        if (menu) {
            menu.classList.remove('show');
        }
    }
}


/**
 * Advanced Export Module
 * Robust export using programmatic generation instead of DOM rendering
 */
class AdvancedExport {
    constructor() {
        this.initialized = false;
    }

    /**
     * Check if advanced export libraries are loaded
     */
    checkLibraries() {
        const libs = {
            jsPDF: typeof window.jspdf !== 'undefined',
            docx: typeof window.docx !== 'undefined',
            pptxgen: typeof window.PptxGenJS !== 'undefined',
            marked: typeof window.marked !== 'undefined'
        };

        return libs;
    }

    /**
     * Export markdown to PDF programmatically (not screenshot)
     */
    async exportToPDF(markdown, filename = 'document.pdf', options = {}) {
        if (!window.jspdf) {
            throw new Error('jsPDF library not loaded');
        }

        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
            orientation: 'portrait',
            unit: 'mm',
            format: 'a4'
        });

        // Parse markdown to tokens
        const tokens = window.marked.lexer(markdown);

        let yPosition = 20;
        const pageHeight = 297; // A4 height in mm
        const pageWidth = 210; // A4 width in mm
        const margin = 20;
        const maxWidth = pageWidth - (margin * 2);

        // Process each token
        for (const token of tokens) {
            // Check if we need a new page
            if (yPosition > pageHeight - 30) {
                doc.addPage();
                yPosition = 20;
            }

            switch (token.type) {
                case 'heading':
                    const headingSizes = { 1: 24, 2: 20, 3: 16, 4: 14, 5: 12, 6: 10 };
                    const fontSize = headingSizes[token.depth] || 12;
                    doc.setFontSize(fontSize);
                    doc.setFont(undefined, 'bold');
                    doc.text(token.text, margin, yPosition);
                    yPosition += fontSize * 0.6;
                    doc.setFont(undefined, 'normal');
                    break;

                case 'paragraph':
                    doc.setFontSize(11);
                    const lines = doc.splitTextToSize(token.text, maxWidth);
                    doc.text(lines, margin, yPosition);
                    yPosition += lines.length * 5 + 5;
                    break;

                case 'list':
                    doc.setFontSize(11);
                    token.items.forEach(item => {
                        const bullet = token.ordered ? `${item.task ? '‚òê' : '‚Ä¢'}` : '‚Ä¢';
                        const itemLines = doc.splitTextToSize(`${bullet} ${item.text}`, maxWidth - 5);
                        doc.text(itemLines, margin + 5, yPosition);
                        yPosition += itemLines.length * 5 + 2;
                    });
                    yPosition += 5;
                    break;

                case 'blockquote':
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'italic');
                    doc.setDrawColor(0, 122, 204);
                    doc.line(margin, yPosition - 3, margin, yPosition + 10);
                    const quoteLines = doc.splitTextToSize(token.text, maxWidth - 10);
                    doc.text(quoteLines, margin + 5, yPosition);
                    yPosition += quoteLines.length * 5 + 10;
                    doc.setFont(undefined, 'normal');
                    break;

                case 'code':
                    doc.setFillColor(240, 240, 240);
                    doc.rect(margin, yPosition - 3, maxWidth, 10 + (token.text.split('\n').length * 4), 'F');
                    doc.setFontSize(9);
                    doc.setFont('courier');
                    const codeLines = token.text.split('\n');
                    codeLines.forEach((line, index) => {
                        doc.text(line, margin + 2, yPosition + (index * 4));
                    });
                    yPosition += codeLines.length * 4 + 12;
                    doc.setFont(undefined, 'normal');
                    break;

                case 'table':
                    // Simple table rendering
                    const rows = token.rows.map(r => r.map(c => c.text));
                    const headers = token.header.map(h => h.text);

                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    const colWidth = maxWidth / headers.length;

                    // Headers
                    headers.forEach((header, i) => {
                        doc.text(header, margin + (i * colWidth), yPosition);
                    });
                    yPosition += 6;
                    doc.setFont(undefined, 'normal');

                    // Rows
                    rows.forEach(row => {
                        row.forEach((cell, i) => {
                            doc.text(cell, margin + (i * colWidth), yPosition);
                        });
                        yPosition += 5;
                    });
                    yPosition += 5;
                    break;

                case 'hr':
                    doc.setDrawColor(200, 200, 200);
                    doc.line(margin, yPosition, pageWidth - margin, yPosition);
                    yPosition += 10;
                    break;

                case 'space':
                    yPosition += 5;
                    break;

                default:
                    // Handle other types
                    if (token.text) {
                        doc.setFontSize(11);
                        const defaultLines = doc.splitTextToSize(token.text, maxWidth);
                        doc.text(defaultLines, margin, yPosition);
                        yPosition += defaultLines.length * 5 + 3;
                    }
            }
        }

        // Add page numbers
        const pageCount = doc.internal.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            doc.setFontSize(9);
            doc.setTextColor(150);
            doc.text(`Page ${i} of ${pageCount}`, pageWidth - margin - 20, pageHeight - 10);
        }

        doc.save(filename);
    }

    /**
     * Export markdown to DOCX programmatically
     */
    async exportToDOCX(markdown, filename = 'document.docx') {
        if (!window.docx) {
            throw new Error('docx library not loaded');
        }

        const { Document, Paragraph, TextRun, HeadingLevel, AlignmentType, Table, TableCell, TableRow, WidthType } = window.docx;

        const tokens = window.marked.lexer(markdown);
        const children = [];

        // Process each token
        for (const token of tokens) {
            switch (token.type) {
                case 'heading':
                    const headingLevels = {
                        1: HeadingLevel.HEADING_1,
                        2: HeadingLevel.HEADING_2,
                        3: HeadingLevel.HEADING_3,
                        4: HeadingLevel.HEADING_4,
                        5: HeadingLevel.HEADING_5,
                        6: HeadingLevel.HEADING_6
                    };
                    children.push(new Paragraph({
                        text: token.text,
                        heading: headingLevels[token.depth]
                    }));
                    break;

                case 'paragraph':
                    children.push(new Paragraph({
                        children: [new TextRun(token.text)],
                        spacing: { after: 200 }
                    }));
                    break;

                case 'list':
                    token.items.forEach((item, index) => {
                        children.push(new Paragraph({
                            text: item.text,
                            bullet: token.ordered ? undefined : { level: 0 },
                            numbering: token.ordered ? { reference: "default-numbering", level: 0 } : undefined
                        }));
                    });
                    break;

                case 'blockquote':
                    children.push(new Paragraph({
                        children: [new TextRun({ text: token.text, italics: true })],
                        indent: { left: 720 },
                        border: {
                            left: {
                                color: "0066CC",
                                space: 1,
                                value: "single",
                                size: 6
                            }
                        }
                    }));
                    break;

                case 'code':
                    children.push(new Paragraph({
                        children: [new TextRun({
                            text: token.text,
                            font: "Courier New",
                            size: 20
                        })],
                        shading: {
                            fill: "F0F0F0"
                        }
                    }));
                    break;

                case 'table':
                    const tableRows = token.rows.map(row =>
                        new TableRow({
                            children: row.map(cell =>
                                new TableCell({
                                    children: [new Paragraph(cell.text)]
                                })
                            )
                        })
                    );

                    const headerRow = new TableRow({
                        children: token.header.map(cell =>
                            new TableCell({
                                children: [new Paragraph({
                                    children: [new TextRun({ text: cell.text, bold: true })]
                                })],
                                shading: { fill: "CCCCCC" }
                            })
                        )
                    });

                    children.push(new Table({
                        rows: [headerRow, ...tableRows],
                        width: {
                            size: 100,
                            type: WidthType.PERCENTAGE
                        }
                    }));
                    break;

                case 'hr':
                    children.push(new Paragraph({
                        border: {
                            bottom: {
                                color: "CCCCCC",
                                space: 1,
                                value: "single",
                                size: 6
                            }
                        }
                    }));
                    break;

                case 'space':
                    children.push(new Paragraph({ text: "" }));
                    break;
            }
        }

        const doc = new Document({
            sections: [{
                properties: {},
                children: children
            }]
        });

        // Generate and download
        const blob = await window.docx.Packer.toBlob(doc);
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }

    /**
     * Export markdown to PowerPoint programmatically
     */
    async exportToPPTX(markdown, filename = 'presentation.pptx', template = null) {
        if (!window.PptxGenJS) {
            throw new Error('PptxGenJS library not loaded');
        }

        const pptx = new window.PptxGenJS();

        // Apply template if provided
        if (template) {
            pptx.layout = 'LAYOUT_16x9';
            // Set default text properties based on template
            if (template.styling) {
                pptx.defineSlideMaster({
                    title: 'MASTER_SLIDE',
                    background: { color: template.styling.backgroundColor },
                    objects: []
                });
            }
        }

        // Split markdown by slides (---)
        const slides = markdown.split(/^---$/m);

        for (const slideContent of slides) {
            if (!slideContent.trim()) continue;

            const slide = pptx.addSlide();

            // Apply template background if available
            if (template && template.slideLayouts) {
                const isFirstSlide = slides[0] === slideContent;
                const layout = isFirstSlide ? template.slideLayouts.title : template.slideLayouts.content;

                if (layout && layout.background) {
                    slide.background = { color: layout.background.replace('#', '') };
                }
            }

            // Parse slide content
            const tokens = window.marked.lexer(slideContent.trim());

            let yPosition = 10; // percentage

            for (const token of tokens) {
                switch (token.type) {
                    case 'heading':
                        const headingSizes = { 1: 44, 2: 36, 3: 28, 4: 24, 5: 20, 6: 18 };
                        slide.addText(token.text, {
                            x: '5%',
                            y: `${yPosition}%`,
                            w: '90%',
                            h: '15%',
                            fontSize: headingSizes[token.depth],
                            bold: true,
                            color: template?.styling?.primaryColor?.replace('#', '') || '000000',
                            fontFace: template?.styling?.headingFont || 'Arial',
                            align: 'center'
                        });
                        yPosition += 18;
                        break;

                    case 'paragraph':
                        slide.addText(token.text, {
                            x: '8%',
                            y: `${yPosition}%`,
                            w: '84%',
                            h: '10%',
                            fontSize: 18,
                            color: template?.styling?.textColor?.replace('#', '') || '333333',
                            fontFace: template?.styling?.bodyFont || 'Arial'
                        });
                        yPosition += 12;
                        break;

                    case 'list':
                        const bulletPoints = token.items.map(item => ({ text: item.text }));
                        slide.addText(bulletPoints, {
                            x: '10%',
                            y: `${yPosition}%`,
                            w: '80%',
                            h: '60%',
                            fontSize: 16,
                            bullet: !token.ordered,
                            color: template?.styling?.textColor?.replace('#', '') || '333333'
                        });
                        yPosition += 50;
                        break;

                    case 'code':
                        slide.addText(token.text, {
                            x: '8%',
                            y: `${yPosition}%`,
                            w: '84%',
                            h: '30%',
                            fontSize: 14,
                            fontFace: 'Courier New',
                            fill: { color: 'F5F5F5' },
                            color: '000000'
                        });
                        yPosition += 35;
                        break;

                    case 'table':
                        const rows = [[...token.header.map(h => h.text)], ...token.rows.map(r => r.map(c => c.text))];
                        slide.addTable(rows, {
                            x: '8%',
                            y: `${yPosition}%`,
                            w: '84%',
                            fontSize: 12,
                            border: { pt: 1, color: 'CCCCCC' }
                        });
                        yPosition += 40;
                        break;
                }

                // Prevent overflow
                if (yPosition > 85) break;
            }

            // Add logo if template has it
            if (template && template.logo && template.logo.enabled && template.logo.url) {
                const logoPos = this.getLogoPosition(template.logo.position);
                slide.addImage({
                    path: template.logo.url,
                    ...logoPos,
                    sizing: { type: 'contain', w: 1, h: 0.5 }
                });
            }

            // Add footer if template has it
            if (template && template.footer && template.footer.enabled) {
                const footerPos = this.getFooterPosition(template.footer.position);
                slide.addText(template.footer.text, {
                    ...footerPos,
                    fontSize: 10,
                    color: '999999'
                });
            }
        }

        await pptx.writeFile({ fileName: filename });
    }

    /**
     * Get logo position for PowerPoint
     */
    getLogoPosition(position) {
        const positions = {
            'top-left': { x: 0.2, y: 0.2 },
            'top-right': { x: 8.8, y: 0.2 },
            'bottom-left': { x: 0.2, y: 7 },
            'bottom-right': { x: 8.8, y: 7 }
        };
        return positions[position] || positions['top-right'];
    }

    /**
     * Get footer position for PowerPoint
     */
    getFooterPosition(position) {
        const positions = {
            'bottom-left': { x: 0.5, y: 7.2, w: 3, h: 0.3 },
            'bottom-center': { x: 4, y: 7.2, w: 3, h: 0.3 },
            'bottom-right': { x: 7, y: 7.2, w: 2.5, h: 0.3 }
        };
        return positions[position] || positions['bottom-right'];
    }

    /**
     * Export markdown to HTML (standalone, enhanced)
     */
    exportToHTML(markdown, filename = 'document.html', template = null) {
        const html = window.marked.parse(markdown);

        const styling = template?.styling || {
            bodyFont: "'Arial', sans-serif",
            headingFont: "'Arial', sans-serif",
            primaryColor: '#333',
            backgroundColor: '#fff',
            textColor: '#333'
        };

        const fullHTML = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            font-family: ${styling.bodyFont};
            max-width: 800px;
            margin: 40px auto;
            padding: 20px;
            background: ${styling.backgroundColor};
            color: ${styling.textColor};
            line-height: 1.6;
        }
        h1, h2, h3, h4, h5, h6 {
            font-family: ${styling.headingFont};
            color: ${styling.primaryColor};
            margin-top: 24px;
            margin-bottom: 16px;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code { background: #f5f5f5; padding: 2px 6px; border-radius: 3px; font-family: 'Courier New', monospace; }
        pre { background: #f5f5f5; padding: 16px; border-radius: 6px; overflow-x: auto; }
        pre code { background: none; padding: 0; }
        blockquote { border-left: 4px solid #ddd; padding-left: 16px; color: #666; margin: 0; }
        table { border-collapse: collapse; width: 100%; margin: 16px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f5f5f5; font-weight: bold; }
        img { max-width: 100%; height: auto; }
        a { color: #0066cc; text-decoration: none; }
        a:hover { text-decoration: underline; }
    </style>
</head>
<body>
${html}
</body>
</html>`;

        const blob = new Blob([fullHTML], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }
}


/**
 * Sync Module - Handles synchronization between editor, preview, and mindmap
 */
class SyncManager {
    constructor(editor, preview, mindmap) {
        this.editor = editor;
        this.preview = preview;
        this.mindmap = mindmap;
        this.isScrolling = false;
        this.scrollTimeout = null;
        this.enabled = true;
    }

    /**
     * Initialize synchronization
     */
    init() {
        this.setupEditorSync();
        this.setupPreviewSync();
        this.setupBidirectionalSync();
        console.log('Sync manager initialized');
    }

    /**
     * Setup bidirectional editing (preview to editor)
     */
    setupBidirectionalSync() {
        if (this.preview) {
            // Set callback for preview element clicks
            this.preview.onElementClick = (lineNumber) => {
                this.jumpToLine(lineNumber);
            };
        }
    }

    /**
     * Jump to specific line in editor
     */
    jumpToLine(lineNumber) {
        if (!this.editor || !this.editor.cm) return;

        // Scroll to line
        this.editor.cm.scrollIntoView({ line: lineNumber, ch: 0 }, 200);

        // Set cursor to that line
        this.editor.cm.setCursor({ line: lineNumber, ch: 0 });

        // Focus the editor
        this.editor.cm.focus();

        // Highlight the line temporarily
        this.highlightEditorLine(lineNumber);
    }

    /**
     * Highlight a line in the editor temporarily
     */
    highlightEditorLine(lineNumber) {
        if (!this.editor || !this.editor.cm) return;

        const lineHandle = this.editor.cm.getLineHandle(lineNumber);
        if (!lineHandle) return;

        // Add temporary highlight class
        this.editor.cm.addLineClass(lineNumber, 'background', 'editor-highlight-line');

        // Remove after 2 seconds
        setTimeout(() => {
            this.editor.cm.removeLineClass(lineNumber, 'background', 'editor-highlight-line');
        }, 2000);
    }

    /**
     * Enable/disable synchronization
     */
    setEnabled(enabled) {
        this.enabled = enabled;
    }

    /**
     * Setup editor scroll synchronization
     */
    setupEditorSync() {
        if (!this.editor.cm) return;

        // Sync scroll from editor to preview
        this.editor.cm.on('scroll', () => {
            if (!this.enabled || this.isScrolling) return;

            clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                this.syncEditorToPreview();
            }, 100);
        });

        // Sync cursor position
        this.editor.cm.on('cursorActivity', () => {
            if (!this.enabled) return;
            this.syncCursorPosition();
        });
    }

    /**
     * Setup preview scroll synchronization
     */
    setupPreviewSync() {
        const previewEl = document.getElementById('preview');
        if (!previewEl) return;

        previewEl.addEventListener('scroll', () => {
            if (!this.enabled || this.isScrolling) return;

            clearTimeout(this.scrollTimeout);
            this.scrollTimeout = setTimeout(() => {
                this.syncPreviewToEditor();
            }, 100);
        });
    }

    /**
     * Sync editor scroll to preview
     */
    syncEditorToPreview() {
        if (!this.editor.cm || !this.preview.container) return;

        const editorScrollInfo = this.editor.cm.getScrollInfo();
        const scrollPercentage = editorScrollInfo.top / (editorScrollInfo.height - editorScrollInfo.clientHeight);

        const previewEl = this.preview.container;
        const previewScrollHeight = previewEl.scrollHeight - previewEl.clientHeight;

        this.isScrolling = true;
        previewEl.scrollTop = scrollPercentage * previewScrollHeight;

        setTimeout(() => {
            this.isScrolling = false;
        }, 150);
    }

    /**
     * Sync preview scroll to editor
     */
    syncPreviewToEditor() {
        if (!this.editor.cm || !this.preview.container) return;

        const previewEl = this.preview.container;
        const scrollPercentage = previewEl.scrollTop / (previewEl.scrollHeight - previewEl.clientHeight);

        const editorScrollInfo = this.editor.cm.getScrollInfo();
        const editorScrollHeight = editorScrollInfo.height - editorScrollInfo.clientHeight;

        this.isScrolling = true;
        this.editor.cm.scrollTo(null, scrollPercentage * editorScrollHeight);

        setTimeout(() => {
            this.isScrolling = false;
        }, 150);
    }

    /**
     * Sync cursor position to preview and mindmap
     */
    syncCursorPosition() {
        if (!this.editor.cm) return;

        const cursor = this.editor.cm.getCursor();
        const line = cursor.line;

        // Get the text up to cursor
        const textUpToCursor = this.editor.cm.getRange({ line: 0, ch: 0 }, cursor);

        // Count headings to sync with mindmap
        const headings = textUpToCursor.match(/^#+\s/gm);
        const headingCount = headings ? headings.length : 0;

        // Highlight current section in preview
        this.highlightPreviewSection(line);

        // Highlight current node in mindmap
        this.highlightMindmapNode(headingCount);
    }

    /**
     * Highlight section in preview based on editor line
     */
    highlightPreviewSection(line) {
        if (!this.preview.container) return;

        // Remove previous highlights
        const previews = this.preview.container.querySelectorAll('.sync-highlight');
        previews.forEach(el => el.classList.remove('sync-highlight'));

        // Find corresponding element
        // This is a simplified version - could be enhanced with line mapping
        const content = this.editor.getValue();
        const lines = content.split('\n');
        let currentHeading = null;

        for (let i = 0; i <= line; i++) {
            if (lines[i].match(/^#+\s/)) {
                currentHeading = lines[i];
            }
        }

        if (currentHeading) {
            const headingText = currentHeading.replace(/^#+\s/, '').trim();
            const headingElements = this.preview.container.querySelectorAll('h1, h2, h3, h4, h5, h6');

            headingElements.forEach(el => {
                if (el.textContent.trim() === headingText) {
                    el.classList.add('sync-highlight');
                    // Scroll into view if needed
                    el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            });
        }
    }

    /**
     * Highlight node in mindmap
     */
    highlightMindmapNode(nodeIndex) {
        if (this.mindmap && this.mindmap.instance && this.mindmap.focusEnabled) {
            // Highlight the node using the new focus feature
            this.mindmap.highlightNode(nodeIndex);
        }
    }

    /**
     * Get line mapping between editor and preview
     */
    getLineMapping() {
        const content = this.editor.getValue();
        const lines = content.split('\n');
        const mapping = [];

        let htmlOffset = 0;
        lines.forEach((line, index) => {
            mapping[index] = htmlOffset;
            // Estimate HTML offset (simplified)
            if (line.trim()) htmlOffset++;
        });

        return mapping;
    }

    /**
     * Scroll to specific heading in all panels
     */
    scrollToHeading(headingText) {
        // Scroll in editor
        if (this.editor.cm) {
            const content = this.editor.getValue();
            const lines = content.split('\n');
            const lineIndex = lines.findIndex(line =>
                line.match(/^#+\s/) && line.includes(headingText)
            );

            if (lineIndex >= 0) {
                this.editor.cm.scrollIntoView({ line: lineIndex, ch: 0 }, 200);
            }
        }

        // Scroll in preview
        if (this.preview.container) {
            const headings = this.preview.container.querySelectorAll('h1, h2, h3, h4, h5, h6');
            headings.forEach(h => {
                if (h.textContent.includes(headingText)) {
                    h.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        }
    }
}


/**
 * Charts Extension - Adds Chart.js support to markdown
 */
class ChartsExtension {
    constructor() {
        this.charts = [];
    }

    /**
     * Initialize charts extension
     */
    init() {
        if (!window.Chart) {
            console.warn('Chart.js not loaded');
            return false;
        }

        console.log('Charts extension initialized');
        return true;
    }

    /**
     * Process markdown and render charts
     */
    process(container) {
        if (!window.Chart || !container) return;

        // Find chart code blocks
        const chartBlocks = container.querySelectorAll('pre code.language-chart');

        chartBlocks.forEach((block, index) => {
            try {
                const config = JSON.parse(block.textContent);

                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.id = `chart-${Date.now()}-${index}`;
                canvas.style.maxWidth = '100%';
                canvas.style.height = 'auto';

                // Replace code block with canvas
                const pre = block.parentElement;
                const wrapper = document.createElement('div');
                wrapper.className = 'chart-wrapper';
                wrapper.style.padding = '20px';
                wrapper.style.background = 'var(--bg-secondary)';
                wrapper.style.borderRadius = '8px';
                wrapper.style.margin = '1em 0';
                wrapper.appendChild(canvas);

                pre.parentElement.replaceChild(wrapper, pre);

                // Create chart
                const chart = new Chart(canvas, config);
                this.charts.push(chart);

            } catch (error) {
                console.error('Chart render error:', error);
                block.parentElement.innerHTML = `<p style="color: red;">Chart Error: ${error.message}</p>`;
            }
        });
    }

    /**
     * Destroy all charts
     */
    destroy() {
        this.charts.forEach(chart => chart.destroy());
        this.charts = [];
    }

    /**
     * Get example chart markdown
     */
    static getExample() {
        return `### Bar Chart Example
\`\`\`chart
{
  "type": "bar",
  "data": {
    "labels": ["Jan", "Feb", "Mar", "Apr", "May", "Jun"],
    "datasets": [{
      "label": "Sales 2024",
      "data": [12, 19, 15, 25, 22, 30],
      "backgroundColor": "rgba(0, 122, 204, 0.6)",
      "borderColor": "rgba(0, 122, 204, 1)",
      "borderWidth": 1
    }]
  },
  "options": {
    "responsive": true,
    "plugins": {
      "legend": {
        "display": true,
        "position": "top"
      }
    },
    "scales": {
      "y": {
        "beginAtZero": true
      }
    }
  }
}
\`\`\`

### Line Chart Example
\`\`\`chart
{
  "type": "line",
  "data": {
    "labels": ["Week 1", "Week 2", "Week 3", "Week 4"],
    "datasets": [{
      "label": "Revenue",
      "data": [65, 78, 90, 81],
      "fill": false,
      "borderColor": "rgb(75, 192, 192)",
      "tension": 0.1
    }]
  },
  "options": {
    "responsive": true
  }
}
\`\`\`

### Pie Chart Example
\`\`\`chart
{
  "type": "pie",
  "data": {
    "labels": ["Product A", "Product B", "Product C"],
    "datasets": [{
      "data": [300, 150, 100],
      "backgroundColor": [
        "rgba(255, 99, 132, 0.6)",
        "rgba(54, 162, 235, 0.6)",
        "rgba(255, 206, 86, 0.6)"
      ]
    }]
  },
  "options": {
    "responsive": true
  }
}
\`\`\``;
    }
}


/**
 * Timeline Extension - Adds timeline support via Mermaid Gantt and Timesheet.js
 */
class TimelineExtension {
    constructor() {
        this.initialized = false;
        this.timesheetLoaded = false;
        this.timelineCounter = 0;
    }

    /**
     * Initialize timeline extension
     */
    init() {
        if (!window.mermaid) {
            console.warn('Mermaid not loaded, timeline support disabled');
            return false;
        }

        // Load timesheet.js CSS and JS
        this.loadTimesheetLibrary();

        this.initialized = true;
        console.log('Timeline extension initialized');
        return true;
    }

    /**
     * Load timesheet.js library
     */
    loadTimesheetLibrary() {
        // Add timesheet.js CSS
        if (!document.getElementById('timesheet-css')) {
            const css = document.createElement('style');
            css.id = 'timesheet-css';
            css.textContent = `
                /* Timesheet.js Styles */
                .timesheet {
                    margin: 20px 0;
                    background: var(--bg-secondary);
                    border-radius: 6px;
                    padding: 20px;
                    overflow-x: auto;
                }

                .timesheet .scale {
                    display: flex;
                    border-bottom: 2px solid var(--border);
                    padding-bottom: 10px;
                    margin-bottom: 20px;
                }

                .timesheet .scale .year {
                    flex: 1;
                    text-align: center;
                    font-weight: bold;
                    color: var(--text-primary);
                    font-size: 14px;
                }

                .timesheet .timeline-row {
                    position: relative;
                    margin-bottom: 15px;
                    min-height: 40px;
                }

                .timesheet .timeline-label {
                    font-weight: 500;
                    color: var(--text-secondary);
                    margin-bottom: 5px;
                    font-size: 12px;
                }

                .timesheet .timeline-bar {
                    position: relative;
                    height: 30px;
                }

                .timesheet .timeline-event {
                    position: absolute;
                    height: 100%;
                    border-radius: 4px;
                    display: flex;
                    align-items: center;
                    padding: 0 10px;
                    font-size: 11px;
                    color: white;
                    overflow: hidden;
                    white-space: nowrap;
                    text-overflow: ellipsis;
                    cursor: pointer;
                    transition: transform 0.2s, box-shadow 0.2s;
                }

                .timesheet .timeline-event:hover {
                    transform: translateY(-2px);
                    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                    z-index: 10;
                }

                .timesheet .timeline-event.color-1 { background: #007acc; }
                .timesheet .timeline-event.color-2 { background: #00aa66; }
                .timesheet .timeline-event.color-3 { background: #ff6b6b; }
                .timesheet .timeline-event.color-4 { background: #ffa500; }
                .timesheet .timeline-event.color-5 { background: #9b59b6; }
                .timesheet .timeline-event.color-6 { background: #3498db; }
            `;
            document.head.appendChild(css);
        }

        this.timesheetLoaded = true;
    }

    /**
     * Process timeline blocks in preview
     */
    process(container) {
        if (!container || !this.timesheetLoaded) return;

        // Find timesheet code blocks
        const timesheetBlocks = container.querySelectorAll('pre code.language-timesheet');

        timesheetBlocks.forEach((block) => {
            try {
                const data = JSON.parse(block.textContent);
                const timeline = this.createTimeline(data);

                // Replace code block with timeline
                const pre = block.parentElement;
                pre.parentElement.replaceChild(timeline, pre);
            } catch (error) {
                console.error('Timesheet render error:', error);
            }
        });
    }

    /**
     * Create timeline from data
     */
    createTimeline(data) {
        const container = document.createElement('div');
        container.className = 'timesheet';
        container.id = `timesheet-${this.timelineCounter++}`;

        // Parse years
        const years = this.extractYears(data.events);

        // Create scale
        const scale = document.createElement('div');
        scale.className = 'scale';
        years.forEach(year => {
            const yearEl = document.createElement('div');
            yearEl.className = 'year';
            yearEl.textContent = year;
            scale.appendChild(yearEl);
        });
        container.appendChild(scale);

        // Create timeline rows
        data.sections.forEach((section, sectionIndex) => {
            const row = document.createElement('div');
            row.className = 'timeline-row';

            const label = document.createElement('div');
            label.className = 'timeline-label';
            label.textContent = section.name;
            row.appendChild(label);

            const bar = document.createElement('div');
            bar.className = 'timeline-bar';

            // Add events for this section
            data.events
                .filter(event => event.section === section.name)
                .forEach((event, eventIndex) => {
                    const eventEl = this.createEventElement(event, years, eventIndex, sectionIndex);
                    bar.appendChild(eventEl);
                });

            row.appendChild(bar);
            container.appendChild(row);
        });

        return container;
    }

    /**
     * Create event element
     */
    createEventElement(event, years, eventIndex, sectionIndex) {
        const el = document.createElement('div');
        el.className = `timeline-event color-${(sectionIndex % 6) + 1}`;
        el.textContent = event.label;
        el.title = `${event.label}\n${event.start} - ${event.end}`;

        // Calculate position and width
        const startYear = parseInt(event.start.split('-')[0]);
        const endYear = parseInt(event.end.split('-')[0]);
        const totalYears = years[years.length - 1] - years[0] + 1;

        const left = ((startYear - years[0]) / totalYears) * 100;
        const width = ((endYear - startYear + 1) / totalYears) * 100;

        el.style.left = `${left}%`;
        el.style.width = `${width}%`;

        return el;
    }

    /**
     * Extract years from events
     */
    extractYears(events) {
        const years = new Set();

        events.forEach(event => {
            const startYear = parseInt(event.start.split('-')[0]);
            const endYear = parseInt(event.end.split('-')[0]);

            for (let year = startYear; year <= endYear; year++) {
                years.add(year);
            }
        });

        return Array.from(years).sort((a, b) => a - b);
    }

    /**
     * Get timesheet.js example
     */
    static getTimesheetExample() {
        return `### Project History (Timesheet)

\`\`\`timesheet
{
  "sections": [
    { "name": "Development" },
    { "name": "Design" },
    { "name": "Marketing" }
  ],
  "events": [
    {
      "section": "Development",
      "label": "MVP Development",
      "start": "2020-01",
      "end": "2020-06"
    },
    {
      "section": "Development",
      "label": "Beta Release",
      "start": "2020-07",
      "end": "2020-12"
    },
    {
      "section": "Development",
      "label": "v1.0 Launch",
      "start": "2021-01",
      "end": "2021-03"
    },
    {
      "section": "Development",
      "label": "v2.0 Development",
      "start": "2021-06",
      "end": "2022-06"
    },
    {
      "section": "Design",
      "label": "Brand Identity",
      "start": "2020-01",
      "end": "2020-03"
    },
    {
      "section": "Design",
      "label": "UI/UX Redesign",
      "start": "2020-10",
      "end": "2021-02"
    },
    {
      "section": "Design",
      "label": "Dark Mode",
      "start": "2021-05",
      "end": "2021-07"
    },
    {
      "section": "Marketing",
      "label": "Launch Campaign",
      "start": "2020-12",
      "end": "2021-04"
    },
    {
      "section": "Marketing",
      "label": "Content Marketing",
      "start": "2021-03",
      "end": "2022-12"
    }
  ]
}
\`\`\`

**Timesheet Format:**
- Use JSON to define sections and events
- Each event has: section, label, start (YYYY-MM), end (YYYY-MM)
- Events are automatically color-coded by section
- Hover over events to see details
`;
    }

    /**
     * Get example timeline markdown
     */
    static getGanttExample() {
        return `### Project Timeline (Gantt)
\`\`\`mermaid
gantt
    title Project Development Timeline
    dateFormat YYYY-MM-DD
    section Planning
    Requirements      :done,    req1, 2024-01-01, 2024-01-15
    Design           :done,    des1, 2024-01-16, 2024-01-31
    section Development
    Frontend         :active,  dev1, 2024-02-01, 45d
    Backend          :         dev2, 2024-02-15, 60d
    section Testing
    Unit Tests       :         test1, after dev1, 20d
    Integration      :         test2, after dev2, 15d
    section Deployment
    Staging          :         dep1, after test2, 5d
    Production       :         dep2, after dep1, 3d
\`\`\``;
    }

    /**
     * Get simple timeline example
     */
    static getTimelineExample() {
        return `### Company History (Timeline)
\`\`\`mermaid
timeline
    title History of Our Company
    2010 : Founded in San Francisco
         : First product launch
    2012 : Series A funding
         : Expanded to 50 employees
    2015 : Reached 1M users
         : Opened European office
    2018 : IPO on NASDAQ
         : 500+ employees globally
    2020 : Acquired competitor
         : Launched mobile app
    2024 : 10M+ active users
         : AI-powered features
\`\`\``;
    }

    /**
     * Get journey example
     */
    static getJourneyExample() {
        return `### User Journey
\`\`\`mermaid
journey
    title My Product Development Journey
    section Discovery
      Research: 5: Me, Team
      Brainstorm: 4: Me, Team
      Validate: 3: Me, Users
    section Design
      Wireframes: 4: Me, Designer
      Mockups: 5: Designer
      Prototype: 4: Designer, Dev
    section Development
      Code: 3: Dev Team
      Review: 4: Me, Dev Team
      Test: 2: QA Team
    section Launch
      Deploy: 5: DevOps
      Monitor: 4: Me, Team
      Celebrate: 5: Everyone
\`\`\``;
    }

    /**
     * Get all timeline examples
     */
    static getAllExamples() {
        return `# Timeline & Gantt Chart Examples

${this.getTimesheetExample()}

${this.getGanttExample()}

${this.getTimelineExample()}

${this.getJourneyExample()}

## Gantt Chart Syntax

### Date Formats
- \`YYYY-MM-DD\` : 2024-01-15
- \`YYYY-MM-DD HH:mm\` : 2024-01-15 14:30

### Task Statuses
- \`done\` : Completed task
- \`active\` : Currently in progress
- \`crit\` : Critical path
- (blank) : Scheduled/future task

### Duration
- \`2024-01-01, 2024-01-31\` : Start and end date
- \`2024-01-01, 30d\` : Start date and duration
- \`after task1, 20d\` : After another task

### Sections
\`\`\`
section Section Name
    Task 1 :done, id1, 2024-01-01, 10d
    Task 2 :active, id2, after id1, 15d
\`\`\`

## Tips

1. Use sections to group related tasks
2. Use task IDs to create dependencies
3. Mark critical tasks with \`crit\`
4. Use descriptive task names
5. Keep timelines readable (not too many tasks)
`;
    }
}


/**
 * Interactive Tables Extension
 * Adds sort, filter, and export capabilities to markdown tables
 */
class InteractiveTablesExtension {
    constructor() {
        this.tables = [];
        this.sortState = new Map();
    }

    /**
     * Initialize extension
     */
    init() {
        console.log('Interactive Tables extension initialized');
    }

    /**
     * Process all tables in the preview
     */
    process(container) {
        if (!container) return;

        const tables = container.querySelectorAll('table');
        tables.forEach((table, index) => {
            this.enhanceTable(table, index);
        });
    }

    /**
     * Enhance a single table with interactive features
     */
    enhanceTable(table, index) {
        // Skip if already enhanced
        if (table.classList.contains('interactive-table')) return;

        table.classList.add('interactive-table');
        table.setAttribute('data-table-id', index);

        // Wrap table in container
        const wrapper = document.createElement('div');
        wrapper.className = 'interactive-table-wrapper';
        table.parentNode.insertBefore(wrapper, table);
        wrapper.appendChild(table);

        // Add toolbar
        const toolbar = this.createToolbar(table, index);
        wrapper.insertBefore(toolbar, table);

        // Make headers sortable
        const headers = table.querySelectorAll('thead th');
        headers.forEach((header, colIndex) => {
            header.classList.add('sortable');
            header.setAttribute('data-col-index', colIndex);
            header.style.cursor = 'pointer';
            header.title = 'Click to sort';

            // Add sort icon
            const sortIcon = document.createElement('span');
            sortIcon.className = 'sort-icon';
            sortIcon.innerHTML = ' ‚áÖ';
            header.appendChild(sortIcon);

            header.addEventListener('click', () => {
                this.sortTable(table, colIndex);
            });
        });

        // Store original rows for filtering
        this.storeTableData(table, index);
    }

    /**
     * Create toolbar with filter and export options
     */
    createToolbar(table, index) {
        const toolbar = document.createElement('div');
        toolbar.className = 'table-toolbar';

        // Filter input
        const filterContainer = document.createElement('div');
        filterContainer.className = 'table-filter';

        const filterInput = document.createElement('input');
        filterInput.type = 'text';
        filterInput.placeholder = 'üîç Filter table...';
        filterInput.className = 'table-filter-input';
        filterInput.addEventListener('input', (e) => {
            this.filterTable(table, e.target.value);
        });

        filterContainer.appendChild(filterInput);

        // Export button
        const exportBtn = document.createElement('button');
        exportBtn.className = 'btn table-export-btn';
        exportBtn.innerHTML = 'üì• Export CSV';
        exportBtn.addEventListener('click', () => {
            this.exportTableToCSV(table, `table-${index}`);
        });

        // Row count
        const rowCount = document.createElement('span');
        rowCount.className = 'table-row-count';
        const rows = table.querySelectorAll('tbody tr').length;
        rowCount.textContent = `${rows} rows`;
        rowCount.setAttribute('data-total-rows', rows);

        toolbar.appendChild(filterContainer);
        toolbar.appendChild(exportBtn);
        toolbar.appendChild(rowCount);

        return toolbar;
    }

    /**
     * Store original table data
     */
    storeTableData(table, index) {
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const rows = Array.from(tbody.querySelectorAll('tr'));
        this.tables[index] = {
            table: table,
            originalRows: rows.map(row => row.cloneNode(true)),
            visibleRows: rows.length
        };
    }

    /**
     * Sort table by column
     */
    sortTable(table, colIndex) {
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const rows = Array.from(tbody.querySelectorAll('tr'));
        const tableId = table.getAttribute('data-table-id');

        // Get current sort state
        const sortKey = `${tableId}-${colIndex}`;
        const currentSort = this.sortState.get(sortKey) || 'none';
        let newSort = 'asc';

        if (currentSort === 'none') newSort = 'asc';
        else if (currentSort === 'asc') newSort = 'desc';
        else newSort = 'none';

        // Update sort state
        this.sortState.clear(); // Only one column sorted at a time
        this.sortState.set(sortKey, newSort);

        // Update sort icons
        const headers = table.querySelectorAll('thead th');
        headers.forEach((header, idx) => {
            const icon = header.querySelector('.sort-icon');
            if (idx === colIndex) {
                icon.innerHTML = newSort === 'asc' ? ' ‚Üë' : newSort === 'desc' ? ' ‚Üì' : ' ‚áÖ';
            } else {
                icon.innerHTML = ' ‚áÖ';
            }
        });

        if (newSort === 'none') {
            // Restore original order
            const tableData = this.tables[parseInt(tableId)];
            if (tableData) {
                tbody.innerHTML = '';
                tableData.originalRows.forEach(row => {
                    tbody.appendChild(row.cloneNode(true));
                });
            }
            return;
        }

        // Sort rows
        rows.sort((a, b) => {
            const aCell = a.cells[colIndex];
            const bCell = b.cells[colIndex];

            if (!aCell || !bCell) return 0;

            let aValue = aCell.textContent.trim();
            let bValue = bCell.textContent.trim();

            // Try to parse as numbers
            const aNum = parseFloat(aValue);
            const bNum = parseFloat(bValue);

            if (!isNaN(aNum) && !isNaN(bNum)) {
                return newSort === 'asc' ? aNum - bNum : bNum - aNum;
            }

            // String comparison
            return newSort === 'asc'
                ? aValue.localeCompare(bValue)
                : bValue.localeCompare(aValue);
        });

        // Re-append sorted rows
        rows.forEach(row => tbody.appendChild(row));
    }

    /**
     * Filter table rows
     */
    filterTable(table, filterText) {
        const tbody = table.querySelector('tbody');
        if (!tbody) return;

        const filterLower = filterText.toLowerCase();
        const rows = tbody.querySelectorAll('tr');
        let visibleCount = 0;

        rows.forEach(row => {
            const text = row.textContent.toLowerCase();
            if (text.includes(filterLower)) {
                row.style.display = '';
                visibleCount++;
            } else {
                row.style.display = 'none';
            }
        });

        // Update row count
        const wrapper = table.closest('.interactive-table-wrapper');
        if (wrapper) {
            const rowCount = wrapper.querySelector('.table-row-count');
            if (rowCount) {
                const total = rowCount.getAttribute('data-total-rows');
                rowCount.textContent = filterText
                    ? `${visibleCount} / ${total} rows`
                    : `${total} rows`;
            }
        }
    }

    /**
     * Export table to CSV
     */
    exportTableToCSV(table, filename) {
        const rows = [];

        // Get headers
        const headers = table.querySelectorAll('thead th');
        const headerRow = [];
        headers.forEach(header => {
            // Remove sort icon
            const text = header.textContent.replace(/[‚áÖ‚Üë‚Üì]/g, '').trim();
            headerRow.push(this.escapeCSV(text));
        });
        rows.push(headerRow.join(','));

        // Get visible data rows
        const dataRows = table.querySelectorAll('tbody tr');
        dataRows.forEach(row => {
            if (row.style.display !== 'none') {
                const cells = row.querySelectorAll('td');
                const rowData = [];
                cells.forEach(cell => {
                    rowData.push(this.escapeCSV(cell.textContent.trim()));
                });
                rows.push(rowData.join(','));
            }
        });

        // Create CSV string
        const csv = rows.join('\n');

        // Download
        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}.csv`;
        link.click();
    }

    /**
     * Escape CSV value
     */
    escapeCSV(value) {
        if (value.includes(',') || value.includes('"') || value.includes('\n')) {
            return '"' + value.replace(/"/g, '""') + '"';
        }
        return value;
    }

    /**
     * Clear all enhancements
     */
    clear() {
        this.tables = [];
        this.sortState.clear();
    }
}


/**
 * Task Lists Extension
 * Adds interactive checkboxes to task lists with persistence
 */
class TaskListsExtension {
    constructor() {
        this.tasks = new Map();
    }

    /**
     * Initialize extension
     */
    init() {
        console.log('Task Lists extension initialized');
    }

    /**
     * Process all task lists in the preview
     */
    process(container, markdown) {
        if (!container) return;

        // Find all list items with checkboxes
        const listItems = container.querySelectorAll('li');

        listItems.forEach((li, index) => {
            const text = li.textContent.trim();

            // Check if it's a task list item (starts with [ ] or [x])
            if (text.startsWith('[ ]') || text.startsWith('[x]') || text.startsWith('[X]')) {
                this.enhanceTaskItem(li, index, markdown);
            }
        });
    }

    /**
     * Enhance a task list item
     */
    enhanceTaskItem(li, index, markdown) {
        // Skip if already enhanced
        if (li.classList.contains('task-list-item')) return;

        li.classList.add('task-list-item');

        const text = li.textContent.trim();
        const isChecked = text.startsWith('[x]') || text.startsWith('[X]');

        // Create checkbox
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'task-checkbox';
        checkbox.checked = isChecked;
        checkbox.setAttribute('data-task-index', index);

        // Create label with task text
        const label = document.createElement('label');
        label.className = 'task-label';
        const taskText = text.substring(3).trim(); // Remove [x] or [ ]
        label.textContent = taskText;

        if (isChecked) {
            label.classList.add('completed');
        }

        // Handle checkbox change
        checkbox.addEventListener('change', (e) => {
            this.handleTaskToggle(e, li, label, markdown);
        });

        // Clear existing content and add new elements
        li.innerHTML = '';
        li.appendChild(checkbox);
        li.appendChild(label);

        // Add progress indicator if this is in a list with multiple tasks
        const ul = li.closest('ul');
        if (ul) {
            this.updateTaskListProgress(ul);
        }
    }

    /**
     * Handle task checkbox toggle
     */
    handleTaskToggle(event, li, label, markdown) {
        const checkbox = event.target;
        const isChecked = checkbox.checked;

        // Update label styling
        if (isChecked) {
            label.classList.add('completed');
        } else {
            label.classList.remove('completed');
        }

        // Add visual feedback
        li.classList.add('task-updating');
        setTimeout(() => {
            li.classList.remove('task-updating');
        }, 300);

        // Update progress
        const ul = li.closest('ul');
        if (ul) {
            this.updateTaskListProgress(ul);
        }

        // Trigger callback for editor update (if connected)
        if (this.onTaskChange) {
            const taskIndex = checkbox.getAttribute('data-task-index');
            this.onTaskChange(taskIndex, isChecked, label.textContent);
        }
    }

    /**
     * Update task list progress indicator
     */
    updateTaskListProgress(ul) {
        // Skip if already has progress bar
        let progressBar = ul.previousElementSibling;
        if (!progressBar || !progressBar.classList.contains('task-progress')) {
            progressBar = document.createElement('div');
            progressBar.className = 'task-progress';
            ul.parentNode.insertBefore(progressBar, ul);
        }

        // Count tasks
        const taskItems = ul.querySelectorAll('.task-list-item');
        const total = taskItems.length;
        const completed = ul.querySelectorAll('.task-checkbox:checked').length;
        const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

        // Update progress bar
        progressBar.innerHTML = `
            <div class="task-progress-bar">
                <div class="task-progress-fill" style="width: ${percentage}%"></div>
            </div>
            <div class="task-progress-text">
                ${completed} / ${total} tasks completed (${percentage}%)
            </div>
        `;
    }

    /**
     * Update markdown source with task state
     */
    updateMarkdownTask(markdown, taskIndex, isChecked) {
        const lines = markdown.split('\n');
        let taskCount = 0;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (line.match(/^[-*]\s\[[ xX]\]/)) {
                if (taskCount === parseInt(taskIndex)) {
                    // Update this line
                    const newState = isChecked ? '[x]' : '[ ]';
                    lines[i] = lines[i].replace(/\[[ xX]\]/, newState);
                    break;
                }
                taskCount++;
            }
        }

        return lines.join('\n');
    }

    /**
     * Export task list as checklist
     */
    exportTaskList(ul, filename) {
        const tasks = [];
        const taskItems = ul.querySelectorAll('.task-list-item');

        taskItems.forEach(item => {
            const checkbox = item.querySelector('.task-checkbox');
            const label = item.querySelector('.task-label');
            if (checkbox && label) {
                tasks.push({
                    completed: checkbox.checked,
                    text: label.textContent
                });
            }
        });

        // Create plain text format
        const text = tasks.map(task =>
            `${task.completed ? '[x]' : '[ ]'} ${task.text}`
        ).join('\n');

        // Download
        const blob = new Blob([text], { type: 'text/plain;charset=utf-8;' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `${filename}.txt`;
        link.click();
    }

    /**
     * Get task statistics
     */
    getTaskStats(container) {
        if (!container) return null;

        const taskItems = container.querySelectorAll('.task-list-item');
        const total = taskItems.length;
        const completed = container.querySelectorAll('.task-checkbox:checked').length;

        return {
            total,
            completed,
            pending: total - completed,
            percentage: total > 0 ? Math.round((completed / total) * 100) : 0
        };
    }

    /**
     * Clear all enhancements
     */
    clear() {
        this.tasks.clear();
    }
}


/**
 * MDNotes Pro - Main Application
 * Professional Markdown Editor with Presentation & Visualization
 */
















class MDNotesApp {
    constructor() {
        // Core modules
        this.storage = Storage;
        this.theme = Theme;
        this.fileManager = null;
        this.editor = null;
        this.blockEditor = null;
        this.preview = null;
        this.mindmap = null;
        this.presentation = null;
        this.exportManager = null;

        // Extensions
        this.chartsExt = null;
        this.timelineExt = null;
        this.interactiveTablesExt = null;
        this.taskListsExt = null;

        // Advanced features
        this.syncManager = null;
        this.presentationTemplates = null;
        this.advancedExport = null;

        // State
        this.settings = {
            theme: 'dark',
            font: "'Consolas', monospace",
            fontSize: '13px',
            revealTheme: 'black',
            appName: 'MDNotes Pro',
            toolbarStyle: 'icon-only'
        };

        this.views = {
            editor: true,
            preview: false,
            mindmap: false
        };

        this.editorMode = 'markdown'; // 'markdown' or 'blocks'
        this.currentBlockPageId = null;

        // Presentation templates
        this.templates = {
            basic: `---\ntheme: black\n---\n\n# Presentation Title\n\n---\n\n## Slide 2\n\nYour content here...`,
            principles: `---\ntheme: black\n---\n\n# 7 Key Principles\n\n---\n\n## Principle 1\n\nDescription...`,
            timeline: TimelineExtension.getAllExamples(),
            charts: ChartsExtension.getExample()
        };
    }

    /**
     * Initialize application
     */
    async init() {
        console.log('Initializing MDNotes Pro...');

        // Load settings
        this.loadSettings();

        // Apply theme
        this.theme.apply(this.settings.theme);

        // Initialize modules
        this.fileManager = new AdvancedFileSystem(this.storage);
        this.editor = new Editor();
        this.preview = new Preview();
        this.mindmap = new Mindmap();
        this.presentation = new Presentation();

        // Initialize file manager
        this.fileManager.init();
        this.fileManager.onFileChange = (file) => this.loadFile(file);

        // Initialize editor
        await this.editor.init();
        this.editor.onChange = (content) => this.handleEditorChange(content);

        // Initialize preview
        this.preview.init();

        // Initialize mindmap
        await this.mindmap.init();

        // Initialize presentation
        this.presentation.init();

        // Initialize export manager
        this.exportManager = new ExportManager(this.preview, this.presentation);

        // Initialize extensions
        this.chartsExt = new ChartsExtension();
        this.chartsExt.init();

        this.timelineExt = new TimelineExtension();
        this.timelineExt.init();

        this.interactiveTablesExt = new InteractiveTablesExtension();
        this.interactiveTablesExt.init();

        this.taskListsExt = new TaskListsExtension();
        this.taskListsExt.init();

        // Initialize advanced features
        this.syncManager = new SyncManager(this.editor, this.preview, this.mindmap);
        this.syncManager.init();

        this.presentationTemplates = new PresentationTemplates();

        this.advancedExport = new AdvancedExport();

        // Load current file
        const currentFile = this.fileManager.getCurrentFile();
        if (currentFile) {
            this.loadFile(currentFile);
        }

        // Apply settings
        this.applySettings();

        // Setup event listeners
        this.setupEventListeners();

        console.log('MDNotes Pro initialized successfully!');
    }

    /**
     * Load settings from storage
     */
    loadSettings() {
        const saved = this.storage.loadSettings();
        if (saved) {
            this.settings = { ...this.settings, ...saved };
        }
    }

    /**
     * Save settings to storage
     */
    saveSettings() {
        this.storage.saveSettings(this.settings);
    }

    /**
     * Apply all settings
     */
    applySettings() {
        // Apply theme
        this.theme.apply(this.settings.theme);

        // Apply font
        document.documentElement.style.setProperty('--font-family', this.settings.font);
        this.editor.setFontFamily(this.settings.font);

        // Apply font size
        document.documentElement.style.setProperty('--font-size', this.settings.fontSize);
        this.editor.setFontSize(this.settings.fontSize);

        // Apply app name
        const titleSpan = document.querySelector('#appTitle span');
        if (titleSpan) {
            titleSpan.textContent = this.settings.appName;
        }

        // Apply toolbar style
        document.body.setAttribute('data-toolbar-style', this.settings.toolbarStyle);

        // Apply Reveal theme
        this.presentation.setTheme(this.settings.revealTheme);

        // Update settings UI
        this.updateSettingsUI();
    }

    /**
     * Update settings UI elements
     */
    updateSettingsUI() {
        const appNameInput = document.getElementById('appNameInput');
        if (appNameInput) appNameInput.value = this.settings.appName;

        const toolbarStyleSelect = document.getElementById('toolbarStyleSelect');
        if (toolbarStyleSelect) toolbarStyleSelect.value = this.settings.toolbarStyle;

        const fontSelect = document.getElementById('fontSelect');
        if (fontSelect) fontSelect.value = this.settings.font;

        const sizeSelect = document.getElementById('sizeSelect');
        if (sizeSelect) sizeSelect.value = this.settings.fontSize;

        const revealThemeSelect = document.getElementById('revealThemeSelect');
        if (revealThemeSelect) revealThemeSelect.value = this.settings.revealTheme;
    }

    /**
     * Handle editor content change
     */
    handleEditorChange(content) {
        // Auto-save
        this.fileManager.saveCurrentFile(content);

        // Update preview if visible
        if (this.views.preview && !this.presentation.isActive) {
            this.preview.update(content);
            this.chartsExt.process(this.preview.container);
            this.timelineExt.process(this.preview.container);
            this.interactiveTablesExt.process(this.preview.container);
            this.taskListsExt.process(this.preview.container, content);
        }

        // Update mindmap if visible
        if (this.views.mindmap) {
            this.mindmap.render(content);
        }

        // Update status
        this.updateStatus();
    }

    /**
     * Load file into editor
     */
    loadFile(file) {
        if (!file) return;

        this.editor.setValue(file.content);
        this.preview.update(file.content);

        if (this.views.mindmap) {
            this.mindmap.render(file.content);
        }

        this.updateStatus();
    }

    /**
     * Toggle view visibility
     */
    toggleView(viewName) {
        this.views[viewName] = !this.views[viewName];

        // Update UI
        const panels = {
            editor: document.getElementById('editorPanel'),
            preview: document.getElementById('previewPanel'),
            mindmap: document.getElementById('mindmapPanel')
        };

        const buttons = {
            editor: document.getElementById('btnEditor'),
            preview: document.getElementById('btnPreview'),
            mindmap: document.getElementById('btnMindmap')
        };

        Object.keys(this.views).forEach(key => {
            if (panels[key]) {
                panels[key].classList.toggle('hidden', !this.views[key]);
            }
            if (buttons[key]) {
                buttons[key].classList.toggle('active', this.views[key]);
            }
        });

        // Refresh view-specific content
        if (viewName === 'mindmap' && this.views.mindmap) {
            setTimeout(() => this.mindmap.render(this.editor.getValue()), 100);
        }

        if (viewName === 'preview' && this.views.preview) {
            const content = this.editor.getValue();
            this.preview.update(content);
            this.chartsExt.process(this.preview.container);
            this.timelineExt.process(this.preview.container);
            this.interactiveTablesExt.process(this.preview.container);
            this.taskListsExt.process(this.preview.container, content);
        }

        // Refresh editor after layout change
        if (this.editor) {
            setTimeout(() => this.editor.refresh(), 100);
        }
    }

    /**
     * Toggle between Markdown and Block editor modes
     */
    async toggleEditorMode() {
        const newMode = this.editorMode === 'markdown' ? 'blocks' : 'markdown';

        try {
            if (newMode === 'blocks') {
                // Switch to block editor
                await this.switchToBlockEditor();
            } else {
                // Switch to markdown editor
                await this.switchToMarkdownEditor();
            }

            this.editorMode = newMode;

            // Update button label
            const label = document.getElementById('editorModeLabel');
            if (label) {
                label.textContent = newMode === 'markdown' ? 'Markdown' : 'Blocks';
            }

            console.log(`Switched to ${newMode} mode`);
        } catch (error) {
            console.error('Failed to switch editor mode:', error);
            alert(`Failed to switch to ${newMode} mode. Check console for details.`);
        }
    }

    /**
     * Switch to block editor mode
     */
    async switchToBlockEditor() {
        // Hide markdown editor
        const markdownEditor = document.getElementById('editor');
        const mdToolbar = document.getElementById('mdToolbar');
        const blockEditorContainer = document.getElementById('blockEditorContainer');

        if (markdownEditor) markdownEditor.classList.add('hidden');
        if (mdToolbar) mdToolbar.classList.add('hidden');
        if (blockEditorContainer) blockEditorContainer.classList.remove('hidden');

        // Get current markdown content
        const markdown = this.editor.getValue();
        const currentFile = this.fileManager.currentFile;

        // Create or get page for current file
        if (!this.currentBlockPageId) {
            // Check if page exists with this title
            const allPages = await db.getAllPages();
            let existingPage = allPages.find(p => p.title === currentFile);

            if (existingPage) {
                this.currentBlockPageId = existingPage.id;
            } else {
                // Create new page
                this.currentBlockPageId = await db.createPage(currentFile);

                // Convert markdown to blocks
                if (markdown.trim()) {
                    await db.markdownToBlocks(this.currentBlockPageId, markdown);
                }
            }
        }

        // Initialize block editor if not already initialized
        if (!this.blockEditor) {
            this.blockEditor = new BlockEditor(blockEditorContainer);
        }

        // Load the page
        await this.blockEditor.init(this.currentBlockPageId);
    }

    /**
     * Switch to markdown editor mode
     */
    async switchToMarkdownEditor() {
        // Show markdown editor
        const markdownEditor = document.getElementById('editor');
        const mdToolbar = document.getElementById('mdToolbar');
        const blockEditorContainer = document.getElementById('blockEditorContainer');

        if (markdownEditor) markdownEditor.classList.remove('hidden');
        if (mdToolbar) mdToolbar.classList.remove('hidden');
        if (blockEditorContainer) blockEditorContainer.classList.add('hidden');

        // Export blocks to markdown if in block mode
        if (this.blockEditor && this.currentBlockPageId) {
            const markdown = await this.blockEditor.exportToMarkdown();
            this.editor.setValue(markdown);
        }

        // Refresh editor
        if (this.editor) {
            this.editor.refresh();
        }
    }

    /**
     * Toggle presentation mode
     */
    async togglePresentation() {
        const content = this.editor.getValue();
        const wasActive = this.presentation.isActive;

        if (wasActive) {
            this.presentation.stop();
            this.preview.update(content);
            this.chartsExt.process(this.preview.container);
        } else {
            const success = await this.presentation.start(content);
            if (!success) {
                return;
            }
        }

        // Update button state
        const btn = document.getElementById('btnPresentation');
        if (btn) {
            btn.classList.toggle('active', this.presentation.isActive);
        }

        // Update preview title
        const title = document.getElementById('previewTitle');
        if (title) {
            title.textContent = this.presentation.isActive ? 'PRESENTATION' : 'PREVIEW';
        }
    }

    /**
     * Update status bar
     */
    updateStatus() {
        const stats = this.editor.getStats();
        const statusRight = document.getElementById('statusRight');
        if (statusRight) {
            statusRight.textContent = `Lines: ${stats.lines} | Words: ${stats.words} | Chars: ${stats.chars}`;
        }

        const cursorInfo = this.editor.getCursorInfo();
        const statusLeft = document.getElementById('statusLeft');
        if (statusLeft) {
            statusLeft.textContent = `Ln ${cursorInfo.line}, Col ${cursorInfo.column}`;
        }
    }

    /**
     * Setup global event listeners
     */
    setupEventListeners() {
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Save: Ctrl/Cmd + S
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                this.save();
            }

            // New file: Ctrl/Cmd + N
            if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
                e.preventDefault();
                this.showNewFileModal();
            }

            // Bold: Ctrl/Cmd + B (handled by editor)
            // Italic: Ctrl/Cmd + I (handled by editor)
        });

        // Close dropdowns when clicking outside
        document.body.addEventListener('click', (e) => {
            if (!e.target.closest('.export-btn-group')) {
                this.exportManager.hideMenu();
            }
        });
    }

    /**
     * Save current file
     */
    save() {
        const content = this.editor.getValue();
        this.fileManager.saveCurrentFile(content);
        this.showNotification('File saved!', 'success');
    }

    /**
     * Show notification
     */
    showNotification(message, type = 'info') {
        const statusLeft = document.getElementById('statusLeft');
        if (!statusLeft) return;

        const originalText = statusLeft.textContent;
        const originalColor = statusLeft.style.color;

        statusLeft.style.color = type === 'error' ? '#f44336' : '#4caf50';
        statusLeft.textContent = message;

        setTimeout(() => {
            statusLeft.textContent = originalText;
            statusLeft.style.color = originalColor;
        }, 3000);
    }

    /**
     * Show/hide modals
     */
    showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.add('show');
        }
    }

    closeModal() {
        document.querySelectorAll('.modal').forEach(modal => {
            modal.classList.remove('show');
        });
    }

    /**
     * Show confirmation dialog (shadcn-style)
     */
    showConfirmDialog(title, message, onConfirm) {
        const modal = document.createElement('div');
        modal.className = 'modal show';
        modal.innerHTML = `
            <div class="dialog-overlay" onclick="this.closest('.modal').remove()"></div>
            <div class="dialog-content">
                <div class="dialog-header">
                    <div class="dialog-title">${title}</div>
                    <button class="icon-btn" onclick="this.closest('.modal').remove()">‚úï</button>
                </div>
                <div style="padding: 24px; padding-top: 0;">
                    <p style="color: var(--text-secondary);">${message}</p>
                </div>
                <div class="dialog-footer">
                    <button class="btn-shadcn btn-outline btn-md" onclick="this.closest('.modal').remove()">Cancel</button>
                    <button class="btn-shadcn btn-destructive btn-md" id="confirmBtn">Confirm</button>
                </div>
            </div>
        `;

        document.body.appendChild(modal);

        // Handle confirm
        const confirmBtn = modal.querySelector('#confirmBtn');
        confirmBtn.onclick = () => {
            onConfirm();
            modal.remove();
        };

        // Handle escape key
        const handleEscape = (e) => {
            if (e.key === 'Escape') {
                modal.remove();
                document.removeEventListener('keydown', handleEscape);
            }
        };
        document.addEventListener('keydown', handleEscape);
    }

    /**
     * Modal handlers
     */
    showNewFileModal() {
        this.showModal('newFileModal');
        const input = document.getElementById('newFileName');
        if (input) {
            input.value = '';
            input.focus();
        }
    }

    createFile() {
        const input = document.getElementById('newFileName');
        if (!input) return;

        const filename = input.value.trim();
        if (!filename) {
            this.showNotification('Filename cannot be empty', 'error');
            return;
        }

        try {
            this.fileManager.createFile(filename);
            this.closeModal();
            this.showNotification(`File "${filename}" created`, 'success');
        } catch (error) {
            this.showNotification(error.message, 'error');
        }
    }

    showSettings() {
        this.updateSettingsUI();
        this.showModal('settingsModal');
    }

    showHelp() {
        this.showModal('helpModal');
    }

    showPresentationSettings() {
        this.showModal('templatesModal');
    }

    applyTemplateAndSettings() {
        const templateSelect = document.getElementById('templateSelect');
        const revealThemeSelect = document.getElementById('revealThemeSelect');

        if (templateSelect) {
            const template = this.templates[templateSelect.value];
            if (template) {
                this.editor.setValue(template);
            }
        }

        if (revealThemeSelect) {
            this.settings.revealTheme = revealThemeSelect.value;
            this.presentation.setTheme(this.settings.revealTheme);
            this.saveSettings();
        }

        this.closeModal();
    }

    /**
     * Settings handlers
     */
    setAppName(name) {
        this.settings.appName = name || 'MDNotes Pro';
        this.applySettings();
        this.saveSettings();
    }

    setToolbarStyle(style) {
        this.settings.toolbarStyle = style;
        this.applySettings();
        this.saveSettings();
    }

    setTheme(themeName) {
        this.settings.theme = themeName;
        this.theme.apply(themeName);
        this.editor.setTheme(themeName);
        this.saveSettings();

        // Re-render preview for mermaid theme sync
        if (this.views.preview && !this.presentation.isActive) {
            this.preview.update(this.editor.getValue());
            this.chartsExt.process(this.preview.container);
        }
    }

    setFont(font) {
        this.settings.font = font;
        this.applySettings();
        this.saveSettings();
    }

    setFontSize(size) {
        this.settings.fontSize = size;
        this.applySettings();
        this.saveSettings();
    }

    /**
     * File operations
     */
    loadExternalFiles(event) {
        this.fileManager.loadExternalFiles(event.target.files);
    }

    toggleFileManager() {
        this.fileManager.toggleVisibility();
    }

    /**
     * Export operations
     */
    async exportAs(format) {
        const filename = this.fileManager.currentFile?.replace('.md', '') || 'document';
        const content = this.editor.getValue();

        this.exportManager.hideMenu();
        this.showSpinner('Exporting...');

        try {
            await this.exportManager.export(format, content, filename);
            this.showNotification('Export successful!', 'success');
        } catch (error) {
            console.error('Export error:', error);
            this.showNotification('Export failed', 'error');
        } finally {
            this.hideSpinner();
        }
    }

    toggleExportMenu() {
        this.exportManager.showMenu();
    }

    /**
     * Markdown toolbar actions
     */
    insertMarkdown(prefix, suffix, placeholder) {
        this.editor.insertMarkdown(prefix, suffix, placeholder);
    }

    /**
     * Fullscreen toggles
     */
    toggleEditorFullscreen() {
        this.editor.toggleFullscreen();
    }

    togglePreviewFullscreen() {
        this.preview.toggleFullscreen();
    }

    toggleMindmapFullscreen() {
        this.mindmap.toggleFullscreen();
    }

    /**
     * Spinner helpers
     */
    showSpinner(text = 'Loading...') {
        const spinner = document.getElementById('spinnerOverlay');
        const spinnerText = document.getElementById('spinnerText');
        if (spinner) spinner.style.display = 'flex';
        if (spinnerText) spinnerText.textContent = text;
    }

    hideSpinner() {
        const spinner = document.getElementById('spinnerOverlay');
        if (spinner) spinner.style.display = 'none';
    }

    /**
     * Advanced Export Methods
     */
    async exportAdvancedPDF() {
        const filename = this.fileManager.currentFile?.replace('.md', '') || 'document';
        const content = this.editor.getValue();

        this.showSpinner('Generating PDF...');
        try {
            await this.advancedExport.exportToPDF(content, `${filename}.pdf`);
            this.showNotification('PDF exported successfully!', 'success');
        } catch (error) {
            console.error('PDF export error:', error);
            this.showNotification('PDF export failed: ' + error.message, 'error');
        } finally {
            this.hideSpinner();
        }
    }

    async exportAdvancedDOCX() {
        const filename = this.fileManager.currentFile?.replace('.md', '') || 'document';
        const content = this.editor.getValue();

        this.showSpinner('Generating DOCX...');
        try {
            await this.advancedExport.exportToDOCX(content, `${filename}.docx`);
            this.showNotification('DOCX exported successfully!', 'success');
        } catch (error) {
            console.error('DOCX export error:', error);
            this.showNotification('DOCX export failed: ' + error.message, 'error');
        } finally {
            this.hideSpinner();
        }
    }

    async exportAdvancedPPTX(templateName = 'corporate') {
        const filename = this.fileManager.currentFile?.replace('.md', '') || 'presentation';
        const content = this.editor.getValue();
        const template = this.presentationTemplates.getTemplate(templateName);

        this.showSpinner('Generating PowerPoint...');
        try {
            await this.advancedExport.exportToPPTX(content, `${filename}.pptx`, template);
            this.showNotification('PowerPoint exported successfully!', 'success');
        } catch (error) {
            console.error('PPTX export error:', error);
            this.showNotification('PPTX export failed: ' + error.message, 'error');
        } finally {
            this.hideSpinner();
        }
    }

    /**
     * Presentation Template Methods
     */
    applyPresentationTemplate(templateName) {
        if (this.presentation.reveal) {
            this.presentationTemplates.applyTemplate(templateName, this.presentation.reveal);
            this.showNotification(`Template "${templateName}" applied`, 'success');
        }
    }

    exportPresentationTemplate(templateName) {
        this.presentationTemplates.exportTemplate(templateName);
    }

    importPresentationTemplate(jsonString, name) {
        if (this.presentationTemplates.importTemplate(jsonString, name)) {
            this.showNotification(`Template "${name}" imported`, 'success');
        } else {
            this.showNotification('Failed to import template', 'error');
        }
    }

    /**
     * Sync Manager Methods
     */
    toggleSync() {
        if (this.syncManager) {
            const newState = !this.syncManager.enabled;
            this.syncManager.setEnabled(newState);
            this.showNotification(`Sync ${newState ? 'enabled' : 'disabled'}`, 'success');
            return newState;
        }
        return false;
    }

    scrollToHeading(headingText) {
        if (this.syncManager) {
            this.syncManager.scrollToHeading(headingText);
        }
    }

    /**
     * Mindmap Focus Methods
     */
    toggleMindmapFocus() {
        if (this.mindmap) {
            const newState = this.mindmap.toggleFocus();
            this.showNotification(`Mindmap focus ${newState ? 'enabled' : 'disabled'}`, 'success');
            return newState;
        }
        return false;
    }

    focusMindmapNode(nodeIndex) {
        if (this.mindmap) {
            this.mindmap.highlightNode(nodeIndex);
        }
    }
}

// Initialize app when DOM is ready
window.addEventListener('DOMContentLoaded', async () => {
    window.app = new MDNotesApp();
    await window.app.init();
});

MDNotesApp;



    </script>
</body>
</html>
